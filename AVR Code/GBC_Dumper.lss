
GBC_Dumper.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001316  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000f2  00800060  00001316  000013aa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000050  00800152  00800152  0000149c  2**0
                  ALLOC
  3 .debug_aranges 000000e0  00000000  00000000  0000149c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000005f5  00000000  00000000  0000157c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000017f7  00000000  00000000  00001b71  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000009c8  00000000  00000000  00003368  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000185a  00000000  00000000  00003d30  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000440  00000000  00000000  0000558c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000077b  00000000  00000000  000059cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001081  00000000  00000000  00006147  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000060  00000000  00000000  000071c8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
       2:	2c c0       	rjmp	.+88     	; 0x5c <__bad_interrupt>
       4:	2b c0       	rjmp	.+86     	; 0x5c <__bad_interrupt>
       6:	2a c0       	rjmp	.+84     	; 0x5c <__bad_interrupt>
       8:	29 c0       	rjmp	.+82     	; 0x5c <__bad_interrupt>
       a:	28 c0       	rjmp	.+80     	; 0x5c <__bad_interrupt>
       c:	27 c0       	rjmp	.+78     	; 0x5c <__bad_interrupt>
       e:	26 c0       	rjmp	.+76     	; 0x5c <__bad_interrupt>
      10:	25 c0       	rjmp	.+74     	; 0x5c <__bad_interrupt>
      12:	24 c0       	rjmp	.+72     	; 0x5c <__bad_interrupt>
      14:	23 c0       	rjmp	.+70     	; 0x5c <__bad_interrupt>
      16:	33 c8       	rjmp	.-3994   	; 0xfffff07e <__eeprom_end+0xff7ef07e>
      18:	21 c0       	rjmp	.+66     	; 0x5c <__bad_interrupt>
      1a:	20 c0       	rjmp	.+64     	; 0x5c <__bad_interrupt>
      1c:	1f c0       	rjmp	.+62     	; 0x5c <__bad_interrupt>
      1e:	1e c0       	rjmp	.+60     	; 0x5c <__bad_interrupt>
      20:	1d c0       	rjmp	.+58     	; 0x5c <__bad_interrupt>
      22:	1c c0       	rjmp	.+56     	; 0x5c <__bad_interrupt>
      24:	1b c0       	rjmp	.+54     	; 0x5c <__bad_interrupt>

00000026 <__ctors_end>:
      26:	11 24       	eor	r1, r1
      28:	1f be       	out	0x3f, r1	; 63
      2a:	cf e5       	ldi	r28, 0x5F	; 95
      2c:	d4 e0       	ldi	r29, 0x04	; 4
      2e:	de bf       	out	0x3e, r29	; 62
      30:	cd bf       	out	0x3d, r28	; 61

00000032 <__do_copy_data>:
      32:	11 e0       	ldi	r17, 0x01	; 1
      34:	a0 e6       	ldi	r26, 0x60	; 96
      36:	b0 e0       	ldi	r27, 0x00	; 0
      38:	e6 e1       	ldi	r30, 0x16	; 22
      3a:	f3 e1       	ldi	r31, 0x13	; 19
      3c:	02 c0       	rjmp	.+4      	; 0x42 <.do_copy_data_start>

0000003e <.do_copy_data_loop>:
      3e:	05 90       	lpm	r0, Z+
      40:	0d 92       	st	X+, r0

00000042 <.do_copy_data_start>:
      42:	a2 35       	cpi	r26, 0x52	; 82
      44:	b1 07       	cpc	r27, r17
      46:	d9 f7       	brne	.-10     	; 0x3e <.do_copy_data_loop>

00000048 <__do_clear_bss>:
      48:	11 e0       	ldi	r17, 0x01	; 1
      4a:	a2 e5       	ldi	r26, 0x52	; 82
      4c:	b1 e0       	ldi	r27, 0x01	; 1
      4e:	01 c0       	rjmp	.+2      	; 0x52 <.do_clear_bss_start>

00000050 <.do_clear_bss_loop>:
      50:	1d 92       	st	X+, r1

00000052 <.do_clear_bss_start>:
      52:	a2 3a       	cpi	r26, 0xA2	; 162
      54:	b1 07       	cpc	r27, r17
      56:	e1 f7       	brne	.-8      	; 0x50 <.do_clear_bss_loop>
      58:	99 d0       	rcall	.+306    	; 0x18c <main>
      5a:	5b c9       	rjmp	.-3402   	; 0xfffff312 <__eeprom_end+0xff7ef312>

0000005c <__bad_interrupt>:
      5c:	d1 cf       	rjmp	.-94     	; 0x0 <__vectors>

0000005e <ProcessChar>:
	EnableSerialInterrupt();
	return;
}
void ProcessChar(char byte)
{
	if(byte == API_HANDSHAKE_REQUEST)
      5e:	87 31       	cpi	r24, 0x17	; 23
      60:	19 f4       	brne	.+6      	; 0x68 <ProcessChar+0xa>
	{
		cprintf_char(API_HANDSHAKE_ACCEPT);
      62:	86 e0       	ldi	r24, 0x06	; 6
      64:	cb d7       	rcall	.+3990   	; 0xffc <cprintf_char>
      66:	08 95       	ret
		return;
	}
	else if(byte == '\n' || byte == '\r')
      68:	8a 30       	cpi	r24, 0x0A	; 10
      6a:	11 f0       	breq	.+4      	; 0x70 <ProcessChar+0x12>
      6c:	8d 30       	cpi	r24, 0x0D	; 13
      6e:	41 f4       	brne	.+16     	; 0x80 <ProcessChar+0x22>
	{
		if(cmd_size > 0)
      70:	80 91 52 01 	lds	r24, 0x0152
      74:	88 23       	and	r24, r24
      76:	89 f0       	breq	.+34     	; 0x9a <ProcessChar+0x3c>
			//set variable instead of processing command. something in the lines of disabling interrupt while in one that just doesn't work out nicely
			process_cmd = 1;
      78:	81 e0       	ldi	r24, 0x01	; 1
      7a:	80 93 53 01 	sts	0x0153, r24
      7e:	08 95       	ret
		return;
	}
	else if( 
		(cmd_size+1) < MAX_CMD_SIZE
      80:	90 91 52 01 	lds	r25, 0x0152
      84:	e9 2f       	mov	r30, r25
      86:	f0 e0       	ldi	r31, 0x00	; 0
		if(cmd_size > 0)
			//set variable instead of processing command. something in the lines of disabling interrupt while in one that just doesn't work out nicely
			process_cmd = 1;
		return;
	}
	else if( 
      88:	e0 32       	cpi	r30, 0x20	; 32
      8a:	f1 05       	cpc	r31, r1
      8c:	34 f4       	brge	.+12     	; 0x9a <ProcessChar+0x3c>
		(cmd_size+1) < MAX_CMD_SIZE
	)
	{
		//space left!
		cmd[cmd_size] = byte;
      8e:	ea 59       	subi	r30, 0x9A	; 154
      90:	fe 4f       	sbci	r31, 0xFE	; 254
      92:	80 83       	st	Z, r24
		cmd_size++;
      94:	9f 5f       	subi	r25, 0xFF	; 255
      96:	90 93 52 01 	sts	0x0152, r25
      9a:	08 95       	ret

0000009c <ProcessCommand>:
//things that are broken : 

*/

void ProcessCommand(void)
{
      9c:	1f 93       	push	r17
      9e:	cf 93       	push	r28
      a0:	df 93       	push	r29
	process_cmd = 0;
      a2:	10 92 53 01 	sts	0x0153, r1
	DisableSerialInterrupt();
      a6:	cb d7       	rcall	.+3990   	; 0x103e <DisableSerialInterrupt>
	API_SetupPins((PINC & ( 1 << PC1))==0);
      a8:	83 b3       	in	r24, 0x13	; 19
      aa:	86 95       	lsr	r24
      ac:	80 95       	com	r24
      ae:	81 70       	andi	r24, 0x01	; 1
      b0:	87 d7       	rcall	.+3854   	; 0xfc0 <API_SetupPins>
	int8_t ret = API_GetGameInfo();
      b2:	3d d5       	rcall	.+2682   	; 0xb2e <API_GetGameInfo>
      b4:	18 2f       	mov	r17, r24
	
	if(ret > 0)
      b6:	18 16       	cp	r1, r24
      b8:	84 f5       	brge	.+96     	; 0x11a <ProcessCommand+0x7e>
	{
		if(strncmp(cmd,"API_READ_ROM",API_READ_ROM_SIZE) == 0 || strncmp(cmd,"API_READ_RAM",API_READ_RAM_SIZE) == 0 )
      ba:	86 e6       	ldi	r24, 0x66	; 102
      bc:	91 e0       	ldi	r25, 0x01	; 1
      be:	60 e6       	ldi	r22, 0x60	; 96
      c0:	70 e0       	ldi	r23, 0x00	; 0
      c2:	4c e0       	ldi	r20, 0x0C	; 12
      c4:	50 e0       	ldi	r21, 0x00	; 0
      c6:	0c d9       	rcall	.-3560   	; 0xfffff2e0 <__eeprom_end+0xff7ef2e0>
      c8:	ec 01       	movw	r28, r24
      ca:	00 97       	sbiw	r24, 0x00	; 0
      cc:	49 f0       	breq	.+18     	; 0xe0 <ProcessCommand+0x44>
      ce:	86 e6       	ldi	r24, 0x66	; 102
      d0:	91 e0       	ldi	r25, 0x01	; 1
      d2:	6d e6       	ldi	r22, 0x6D	; 109
      d4:	70 e0       	ldi	r23, 0x00	; 0
      d6:	4c e0       	ldi	r20, 0x0C	; 12
      d8:	50 e0       	ldi	r21, 0x00	; 0
      da:	02 d9       	rcall	.-3580   	; 0xfffff2e0 <__eeprom_end+0xff7ef2e0>
      dc:	00 97       	sbiw	r24, 0x00	; 0
      de:	31 f4       	brne	.+12     	; 0xec <ProcessCommand+0x50>
		{
			ROM_TYPE type = (strncmp(cmd,"API_READ_ROM",API_READ_ROM_SIZE) == 0)?TYPE_ROM:TYPE_RAM;
			ret = API_Get_Memory(type);
      e0:	80 e0       	ldi	r24, 0x00	; 0
      e2:	cd 2b       	or	r28, r29
      e4:	09 f0       	breq	.+2      	; 0xe8 <ProcessCommand+0x4c>
      e6:	81 e0       	ldi	r24, 0x01	; 1
      e8:	fa d6       	rcall	.+3572   	; 0xede <API_Get_Memory>
      ea:	0a c0       	rjmp	.+20     	; 0x100 <ProcessCommand+0x64>
		}
		else if(strncmp(cmd,"API_WRITE_RAM",API_WRITE_RAM_SIZE) == 0)
      ec:	86 e6       	ldi	r24, 0x66	; 102
      ee:	91 e0       	ldi	r25, 0x01	; 1
      f0:	6a e7       	ldi	r22, 0x7A	; 122
      f2:	70 e0       	ldi	r23, 0x00	; 0
      f4:	4d e0       	ldi	r20, 0x0D	; 13
      f6:	50 e0       	ldi	r21, 0x00	; 0
      f8:	f3 d8       	rcall	.-3610   	; 0xfffff2e0 <__eeprom_end+0xff7ef2e0>
      fa:	00 97       	sbiw	r24, 0x00	; 0
      fc:	19 f4       	brne	.+6      	; 0x104 <ProcessCommand+0x68>
		{			
			ret = API_WriteRam();	
      fe:	d8 d6       	rcall	.+3504   	; 0xeb0 <API_WriteRam>
     100:	18 2f       	mov	r17, r24
     102:	0b c0       	rjmp	.+22     	; 0x11a <ProcessCommand+0x7e>
		}
		else
		{
			API_Send_Abort(API_ABORT_ERROR);
     104:	81 ef       	ldi	r24, 0xF1	; 241
     106:	f6 d4       	rcall	.+2540   	; 0xaf4 <API_Send_Abort>
			cprintf("COMMAND '");
     108:	88 e8       	ldi	r24, 0x88	; 136
     10a:	90 e0       	ldi	r25, 0x00	; 0
     10c:	80 d7       	rcall	.+3840   	; 0x100e <cprintf_string>
			cprintf(cmd);
     10e:	86 e6       	ldi	r24, 0x66	; 102
     110:	91 e0       	ldi	r25, 0x01	; 1
     112:	7d d7       	rcall	.+3834   	; 0x100e <cprintf_string>
			cprintf("' UNKNOWN\r\n");
     114:	82 e9       	ldi	r24, 0x92	; 146
     116:	90 e0       	ldi	r25, 0x00	; 0
     118:	7a d7       	rcall	.+3828   	; 0x100e <cprintf_string>
		}
	}
	
	//process errors
	if(ret < 0)
     11a:	17 ff       	sbrs	r17, 7
     11c:	29 c0       	rjmp	.+82     	; 0x170 <ProcessCommand+0xd4>
	{
		//if there is no Gameinfo/Cart detected that means we are here from cart detection or before. therefor send an abort.
		//else, just process. it has send its own abort!
		if(!API_CartInserted())
     11e:	a8 d4       	rcall	.+2384   	; 0xa70 <API_CartInserted>
     120:	88 23       	and	r24, r24
     122:	11 f4       	brne	.+4      	; 0x128 <ProcessCommand+0x8c>
			API_Send_Abort(API_ABORT_ERROR);
     124:	81 ef       	ldi	r24, 0xF1	; 241
     126:	e6 d4       	rcall	.+2508   	; 0xaf4 <API_Send_Abort>
		
		switch(ret)
     128:	18 3f       	cpi	r17, 0xF8	; 248
     12a:	a1 f0       	breq	.+40     	; 0x154 <ProcessCommand+0xb8>
     12c:	19 3f       	cpi	r17, 0xF9	; 249
     12e:	2c f4       	brge	.+10     	; 0x13a <ProcessCommand+0x9e>
     130:	13 3e       	cpi	r17, 0xE3	; 227
     132:	69 f0       	breq	.+26     	; 0x14e <ProcessCommand+0xb2>
     134:	16 3f       	cpi	r17, 0xF6	; 246
     136:	a1 f4       	brne	.+40     	; 0x160 <ProcessCommand+0xc4>
     138:	10 c0       	rjmp	.+32     	; 0x15a <ProcessCommand+0xbe>
     13a:	19 3f       	cpi	r17, 0xF9	; 249
     13c:	29 f0       	breq	.+10     	; 0x148 <ProcessCommand+0xac>
     13e:	1a 3f       	cpi	r17, 0xFA	; 250
     140:	79 f4       	brne	.+30     	; 0x160 <ProcessCommand+0xc4>
		{
			case ERR_PACKET_FAILURE:
				cprintf("PCKT_FAILURE");
     142:	8e e9       	ldi	r24, 0x9E	; 158
     144:	90 e0       	ldi	r25, 0x00	; 0
     146:	13 c0       	rjmp	.+38     	; 0x16e <ProcessCommand+0xd2>
				break;
			case ERR_NOK_RETURNED:
				cprintf("NOK_RET");
     148:	8b ea       	ldi	r24, 0xAB	; 171
     14a:	90 e0       	ldi	r25, 0x00	; 0
     14c:	10 c0       	rjmp	.+32     	; 0x16e <ProcessCommand+0xd2>
				break;
			case ERR_NO_SAVE:
				cprintf("NO_SAV");
     14e:	83 eb       	ldi	r24, 0xB3	; 179
     150:	90 e0       	ldi	r25, 0x00	; 0
     152:	0d c0       	rjmp	.+26     	; 0x16e <ProcessCommand+0xd2>
				break;
			case ERR_LOGO_CHECK:
				cprintf("LOGO_CHECK\r\n");
     154:	8a eb       	ldi	r24, 0xBA	; 186
     156:	90 e0       	ldi	r25, 0x00	; 0
     158:	0a c0       	rjmp	.+20     	; 0x16e <ProcessCommand+0xd2>
				break;
			case ERR_FAULT_CART:
				cprintf("FAULT_CART\r\n");
     15a:	87 ec       	ldi	r24, 0xC7	; 199
     15c:	90 e0       	ldi	r25, 0x00	; 0
     15e:	07 c0       	rjmp	.+14     	; 0x16e <ProcessCommand+0xd2>
				break;
			default :
				cprintf("ERR_UNKNOWN :'");
     160:	84 ed       	ldi	r24, 0xD4	; 212
     162:	90 e0       	ldi	r25, 0x00	; 0
     164:	54 d7       	rcall	.+3752   	; 0x100e <cprintf_string>
				cprintf_char(ret);
     166:	81 2f       	mov	r24, r17
     168:	49 d7       	rcall	.+3730   	; 0xffc <cprintf_char>
				cprintf("'\r\n");
     16a:	83 ee       	ldi	r24, 0xE3	; 227
     16c:	90 e0       	ldi	r25, 0x00	; 0
     16e:	4f d7       	rcall	.+3742   	; 0x100e <cprintf_string>
		}		
		goto end_function;
	}
	
end_function:
	cmd_size = 0;
     170:	10 92 52 01 	sts	0x0152, r1
	memset(cmd,0,MAX_CMD_SIZE);
     174:	81 e2       	ldi	r24, 0x21	; 33
     176:	e6 e6       	ldi	r30, 0x66	; 102
     178:	f1 e0       	ldi	r31, 0x01	; 1
     17a:	df 01       	movw	r26, r30
     17c:	1d 92       	st	X+, r1
     17e:	8a 95       	dec	r24
     180:	e9 f7       	brne	.-6      	; 0x17c <ProcessCommand+0xe0>
	EnableSerialInterrupt();
     182:	62 d7       	rcall	.+3780   	; 0x1048 <EnableSerialInterrupt>
	return;
}
     184:	df 91       	pop	r29
     186:	cf 91       	pop	r28
     188:	1f 91       	pop	r17
     18a:	08 95       	ret

0000018c <main>:
		cmd_size++;
	}
	return;
}
int main(void)
{
     18c:	0f 93       	push	r16
     18e:	1f 93       	push	r17
     190:	cf 93       	push	r28
     192:	df 93       	push	r29
	//fire up the usart
	initConsole();
     194:	5e d7       	rcall	.+3772   	; 0x1052 <initConsole>
	
	//setup API
	API_Init();
     196:	27 d7       	rcall	.+3662   	; 0xfe6 <API_Init>
	
	//Set PD2 as Input
	DDRC &= ~(1 << PC1);
     198:	a1 98       	cbi	0x14, 1	; 20
	//disable pull up
	PORTC &= ~(1 << PC1);
     19a:	a9 98       	cbi	0x15, 1	; 21

	//set it so that incoming msg's are ignored.
	setSerialRecvCallback(ProcessChar);
     19c:	8f e2       	ldi	r24, 0x2F	; 47
     19e:	90 e0       	ldi	r25, 0x00	; 0
     1a0:	28 d7       	rcall	.+3664   	; 0xff2 <setSerialRecvCallback>
	cprintf("Atmega8 says : ");
#elif defined(__ATMEGA32__)
	cprintf("Atmega32 says : ");
#endif*/

	cprintf("Ready\r\n");
     1a2:	87 ee       	ldi	r24, 0xE7	; 231
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	33 d7       	rcall	.+3686   	; 0x100e <cprintf_string>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     1a8:	c0 e9       	ldi	r28, 0x90	; 144
     1aa:	d1 e0       	ldi	r29, 0x01	; 1
    // main loop
	// do not kill the loop. despite the console/UART being set as interrupt. going out of main kills the program completely
	uint32_t addr = 0x00000000UL;//0xFF31;//0x13FF;//0x104;//0x200;//0x8421;
    while(1) 
	{
		if(process_cmd)
     1ac:	80 91 53 01 	lds	r24, 0x0153
     1b0:	81 11       	cpse	r24, r1
		{
			ProcessCommand();
     1b2:	74 df       	rcall	.-280    	; 0x9c <ProcessCommand>
		}
		if(CheckControlPin(BTN) == LOW)
     1b4:	84 e0       	ldi	r24, 0x04	; 4
     1b6:	0d d2       	rcall	.+1050   	; 0x5d2 <CheckControlPin>
     1b8:	88 23       	and	r24, r24
     1ba:	c1 f7       	brne	.-16     	; 0x1ac <main+0x20>
		{
			cprintf("Btn pressed!\r\n");
     1bc:	8f ee       	ldi	r24, 0xEF	; 239
     1be:	90 e0       	ldi	r25, 0x00	; 0
     1c0:	26 d7       	rcall	.+3660   	; 0x100e <cprintf_string>
			SetControlPin(CS2,HIGH);
     1c2:	83 e0       	ldi	r24, 0x03	; 3
     1c4:	61 e0       	ldi	r22, 0x01	; 1
     1c6:	eb d1       	rcall	.+982    	; 0x59e <SetControlPin>
			uint16_t data = 0;	
			//expected : 0x2e00	
			//cprintf("address (0x%X): 0x%02X%02X%02X\r\n",addr, addr & 0xFF,(addr >> 8) & 0xFF,(addr >> 16) & 0xFF);*/
			data = ReadGBABytes(addr);
     1c8:	81 e0       	ldi	r24, 0x01	; 1
     1ca:	40 e0       	ldi	r20, 0x00	; 0
     1cc:	50 e0       	ldi	r21, 0x00	; 0
     1ce:	60 e0       	ldi	r22, 0x00	; 0
     1d0:	70 e0       	ldi	r23, 0x00	; 0
     1d2:	55 d0       	rcall	.+170    	; 0x27e <_ReadGBABytes>
     1d4:	8c 01       	movw	r16, r24
			uint8_t d1 = data >> 8;
			uint8_t d2 = data & 0xFF;
			
			cprintf("data : ");
     1d6:	8e ef       	ldi	r24, 0xFE	; 254
     1d8:	90 e0       	ldi	r25, 0x00	; 0
     1da:	19 d7       	rcall	.+3634   	; 0x100e <cprintf_string>
			cprintf_char(d1);	
     1dc:	81 2f       	mov	r24, r17
     1de:	0e d7       	rcall	.+3612   	; 0xffc <cprintf_char>
			cprintf_char(d2);
     1e0:	80 2f       	mov	r24, r16
     1e2:	0c d7       	rcall	.+3608   	; 0xffc <cprintf_char>
			
			cprintf("\r\ndone\r\n");
     1e4:	86 e0       	ldi	r24, 0x06	; 6
     1e6:	91 e0       	ldi	r25, 0x01	; 1
     1e8:	12 d7       	rcall	.+3620   	; 0x100e <cprintf_string>
     1ea:	80 ed       	ldi	r24, 0xD0	; 208
     1ec:	97 e0       	ldi	r25, 0x07	; 7
     1ee:	fe 01       	movw	r30, r28
     1f0:	31 97       	sbiw	r30, 0x01	; 1
     1f2:	f1 f7       	brne	.-4      	; 0x1f0 <main+0x64>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     1f4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     1f6:	d9 f7       	brne	.-10     	; 0x1ee <main+0x62>
     1f8:	d9 cf       	rjmp	.-78     	; 0x1ac <main+0x20>

000001fa <SetGBADataAsInput>:
	mcp23008_WriteReg(ADDR_CHIP_2,IODIR,0x00);
	
}
inline void SetGBADataAsInput(void)
{
	mcp23008_WriteReg(ADDR_CHIP_1,IODIR,0xFF);
     1fa:	80 e4       	ldi	r24, 0x40	; 64
     1fc:	60 e0       	ldi	r22, 0x00	; 0
     1fe:	4f ef       	ldi	r20, 0xFF	; 255
     200:	0f d8       	rcall	.-4066   	; 0xfffff220 <__eeprom_end+0xff7ef220>
	mcp23008_WriteReg(ADDR_CHIP_2,IODIR,0xFF);
     202:	82 e4       	ldi	r24, 0x42	; 66
     204:	60 e0       	ldi	r22, 0x00	; 0
     206:	4f ef       	ldi	r20, 0xFF	; 255
     208:	0b d8       	rcall	.-4074   	; 0xfffff220 <__eeprom_end+0xff7ef220>
	
	//enable pull up
	mcp23008_WriteReg(ADDR_CHIP_1,GPPU,0xFF);
     20a:	80 e4       	ldi	r24, 0x40	; 64
     20c:	66 e0       	ldi	r22, 0x06	; 6
     20e:	4f ef       	ldi	r20, 0xFF	; 255
     210:	07 d8       	rcall	.-4082   	; 0xfffff220 <__eeprom_end+0xff7ef220>
	mcp23008_WriteReg(ADDR_CHIP_2,GPPU,0xFF);
     212:	82 e4       	ldi	r24, 0x42	; 66
     214:	66 e0       	ldi	r22, 0x06	; 6
     216:	4f ef       	ldi	r20, 0xFF	; 255
     218:	03 d8       	rcall	.-4090   	; 0xfffff220 <__eeprom_end+0xff7ef220>
}
     21a:	08 95       	ret

0000021c <SetGBADataAsOutput>:
#endif

inline void SetGBADataAsOutput(void)
{
	//disable pull ups
	mcp23008_WriteReg(ADDR_CHIP_1,GPPU,0x00);
     21c:	80 e4       	ldi	r24, 0x40	; 64
     21e:	66 e0       	ldi	r22, 0x06	; 6
     220:	40 e0       	ldi	r20, 0x00	; 0
     222:	fe d7       	rcall	.+4092   	; 0x1220 <mcp23008_WriteReg>
	mcp23008_WriteReg(ADDR_CHIP_2,GPPU,0x00);
     224:	82 e4       	ldi	r24, 0x42	; 66
     226:	66 e0       	ldi	r22, 0x06	; 6
     228:	40 e0       	ldi	r20, 0x00	; 0
     22a:	fa d7       	rcall	.+4084   	; 0x1220 <mcp23008_WriteReg>
	
	//set output
	mcp23008_WriteReg(ADDR_CHIP_1,IODIR,0x00);
     22c:	80 e4       	ldi	r24, 0x40	; 64
     22e:	60 e0       	ldi	r22, 0x00	; 0
     230:	40 e0       	ldi	r20, 0x00	; 0
     232:	f6 d7       	rcall	.+4076   	; 0x1220 <mcp23008_WriteReg>
	mcp23008_WriteReg(ADDR_CHIP_2,IODIR,0x00);
     234:	82 e4       	ldi	r24, 0x42	; 66
     236:	60 e0       	ldi	r22, 0x00	; 0
     238:	40 e0       	ldi	r20, 0x00	; 0
     23a:	f2 d7       	rcall	.+4068   	; 0x1220 <mcp23008_WriteReg>
	
}
     23c:	08 95       	ret

0000023e <SetGBAAddress>:
	SetPin(CTRL_PORT,RD);
	SetPin(CTRL_PORT,CS1);
	SetPin(CTRL_PORT,CS2);
}
inline void SetGBAAddress(uint32_t address)
{	
     23e:	ef 92       	push	r14
     240:	ff 92       	push	r15
     242:	0f 93       	push	r16
     244:	1f 93       	push	r17
     246:	7b 01       	movw	r14, r22
     248:	8c 01       	movw	r16, r24
#ifdef GPIO_EXTENDER_MODE
	SetGBADataAsOutput();
     24a:	e8 df       	rcall	.-48     	; 0x21c <SetGBADataAsOutput>
	SetDataPinsAsOutput();
     24c:	60 d2       	rcall	.+1216   	; 0x70e <SetDataPinsAsOutput>
	mcp23008_WriteReg(ADDR_CHIP_2,GPIO,(uint8_t)(address & 0xFF));
     24e:	82 e4       	ldi	r24, 0x42	; 66
     250:	69 e0       	ldi	r22, 0x09	; 9
     252:	4e 2d       	mov	r20, r14
     254:	e5 d7       	rcall	.+4042   	; 0x1220 <mcp23008_WriteReg>
	mcp23008_WriteReg(ADDR_CHIP_1,GPIO,(uint8_t)(address >> 8) & 0xFF);
     256:	55 27       	eor	r21, r21
     258:	41 2f       	mov	r20, r17
     25a:	30 2f       	mov	r19, r16
     25c:	2f 2d       	mov	r18, r15
     25e:	80 e4       	ldi	r24, 0x40	; 64
     260:	69 e0       	ldi	r22, 0x09	; 9
     262:	42 2f       	mov	r20, r18
     264:	dd d7       	rcall	.+4026   	; 0x1220 <mcp23008_WriteReg>
	mcp23008_WriteReg(DATA_CHIP_1,GPIO,(uint8_t)(address >> 16) & 0xFF);
     266:	78 01       	movw	r14, r16
     268:	00 27       	eor	r16, r16
     26a:	11 27       	eor	r17, r17
     26c:	84 e4       	ldi	r24, 0x44	; 68
     26e:	69 e0       	ldi	r22, 0x09	; 9
     270:	4e 2d       	mov	r20, r14
     272:	d6 d7       	rcall	.+4012   	; 0x1220 <mcp23008_WriteReg>
#endif
}
     274:	1f 91       	pop	r17
     276:	0f 91       	pop	r16
     278:	ff 90       	pop	r15
     27a:	ef 90       	pop	r14
     27c:	08 95       	ret

0000027e <_ReadGBABytes>:
	
	SetPin(CTRL_PORT,RD);
	return (uint16_t)d1 << 8 | d2;
}
inline uint16_t _ReadGBABytes(uint8_t ReadRom,uint32_t address)
{
     27e:	1f 93       	push	r17
     280:	df 93       	push	r29
     282:	cf 93       	push	r28
     284:	00 d0       	rcall	.+0      	; 0x286 <_ReadGBABytes+0x8>
     286:	cd b7       	in	r28, 0x3d	; 61
     288:	de b7       	in	r29, 0x3e	; 62
     28a:	18 2f       	mov	r17, r24
	uint8_t d1 = 0;
     28c:	19 82       	std	Y+1, r1	; 0x01
	uint8_t d2 = 0;
     28e:	1a 82       	std	Y+2, r1	; 0x02

	SetPin(CTRL_PORT,CS2);
     290:	93 9a       	sbi	0x12, 3	; 18
	SetPin(CTRL_PORT,RD);
     292:	95 9a       	sbi	0x12, 5	; 18
	SetPin(CTRL_PORT,WD);
     294:	96 9a       	sbi	0x12, 6	; 18
	SetPin(CTRL_PORT,CS1);
     296:	97 9a       	sbi	0x12, 7	; 18

	SetGBAAddress(address);
     298:	cb 01       	movw	r24, r22
     29a:	ba 01       	movw	r22, r20
     29c:	d0 df       	rcall	.-96     	; 0x23e <SetGBAAddress>
	
	//latch the address
	if(ReadRom)
     29e:	11 23       	and	r17, r17
     2a0:	11 f0       	breq	.+4      	; 0x2a6 <_ReadGBABytes+0x28>
		ClearPin(CTRL_PORT,CS1);
     2a2:	97 98       	cbi	0x12, 7	; 18
     2a4:	01 c0       	rjmp	.+2      	; 0x2a8 <_ReadGBABytes+0x2a>
	else
		ClearPin(CTRL_PORT,CS2);
     2a6:	93 98       	cbi	0x12, 3	; 18
	
	//set RD low so data pins are set
	ClearPin(CTRL_PORT,RD);
     2a8:	95 98       	cbi	0x12, 5	; 18

#ifdef GPIO_EXTENDER_MODE	
	//set as input so we can read the pins
	SetGBADataAsInput();
     2aa:	a7 df       	rcall	.-178    	; 0x1fa <SetGBADataAsInput>
#endif
	
#ifdef GPIO_EXTENDER_MODE			
	//read data
	mcp23008_ReadReg(ADDR_CHIP_1, GPIO,&d1);
     2ac:	80 e4       	ldi	r24, 0x40	; 64
     2ae:	69 e0       	ldi	r22, 0x09	; 9
     2b0:	ae 01       	movw	r20, r28
     2b2:	4f 5f       	subi	r20, 0xFF	; 255
     2b4:	5f 4f       	sbci	r21, 0xFF	; 255
     2b6:	c8 d7       	rcall	.+3984   	; 0x1248 <mcp23008_ReadReg>
	mcp23008_ReadReg(ADDR_CHIP_2, GPIO,&d2);	
     2b8:	82 e4       	ldi	r24, 0x42	; 66
     2ba:	69 e0       	ldi	r22, 0x09	; 9
     2bc:	ae 01       	movw	r20, r28
     2be:	4e 5f       	subi	r20, 0xFE	; 254
     2c0:	5f 4f       	sbci	r21, 0xFF	; 255
     2c2:	c2 d7       	rcall	.+3972   	; 0x1248 <mcp23008_ReadReg>
#endif
	
	SetPin(CTRL_PORT,CS2);
     2c4:	93 9a       	sbi	0x12, 3	; 18
	SetPin(CTRL_PORT,RD);
     2c6:	95 9a       	sbi	0x12, 5	; 18
	SetPin(CTRL_PORT,CS1);
     2c8:	97 9a       	sbi	0x12, 7	; 18
     2ca:	99 81       	ldd	r25, Y+1	; 0x01
     2cc:	80 e0       	ldi	r24, 0x00	; 0
     2ce:	2a 81       	ldd	r18, Y+2	; 0x02
     2d0:	30 e0       	ldi	r19, 0x00	; 0
     2d2:	28 2b       	or	r18, r24
     2d4:	39 2b       	or	r19, r25
	
	return (uint16_t)d1 << 8 | d2;
}
     2d6:	c9 01       	movw	r24, r18
     2d8:	0f 90       	pop	r0
     2da:	0f 90       	pop	r0
     2dc:	cf 91       	pop	r28
     2de:	df 91       	pop	r29
     2e0:	1f 91       	pop	r17
     2e2:	08 95       	ret

000002e4 <GetGBAInfo>:
	}
	return i;
}

int8_t GetGBAInfo(char* name)
{
     2e4:	7f 92       	push	r7
     2e6:	8f 92       	push	r8
     2e8:	9f 92       	push	r9
     2ea:	af 92       	push	r10
     2ec:	bf 92       	push	r11
     2ee:	cf 92       	push	r12
     2f0:	df 92       	push	r13
     2f2:	ef 92       	push	r14
     2f4:	ff 92       	push	r15
     2f6:	0f 93       	push	r16
     2f8:	1f 93       	push	r17
     2fa:	df 93       	push	r29
     2fc:	cf 93       	push	r28
     2fe:	cd b7       	in	r28, 0x3d	; 61
     300:	de b7       	in	r29, 0x3e	; 62
     302:	c8 5c       	subi	r28, 0xC8	; 200
     304:	d0 40       	sbci	r29, 0x00	; 0
     306:	0f b6       	in	r0, 0x3f	; 63
     308:	f8 94       	cli
     30a:	de bf       	out	0x3e, r29	; 62
     30c:	0f be       	out	0x3f, r0	; 63
     30e:	cd bf       	out	0x3d, r28	; 61
     310:	e8 2e       	mov	r14, r24
     312:	79 2e       	mov	r7, r25
	GBA_Header info;
	uint16_t* ptr = (uint16_t*)&info;
     314:	49 e0       	ldi	r20, 0x09	; 9
     316:	a4 2e       	mov	r10, r20
     318:	b1 2c       	mov	r11, r1
     31a:	ac 0e       	add	r10, r28
     31c:	bd 1e       	adc	r11, r29
		0xFC, 0x03, 0x98, 0x76, 0x23, 0x1D, 0xC7, 0x61, 0x03, 0x04, 0xAE, 0x56, 0xBF, 0x38, 0x84, 0x20,
		0x40, 0xA7, 0x0E, 0xFD, 0xFF, 0x52, 0xFE, 0x03, 0x6F, 0x95, 0x30, 0xF1, 0x97, 0xFB, 0xC0, 0x85,
		0x60, 0xD6, 0x80, 0x25, 0xA9, 0x63, 0xBE, 0x03, 0x01, 0x4E, 0x38, 0xE2, 0xF9, 0xA2, 0x34, 0xFF,
		0xBB, 0x3E, 0x03, 0x44, 0x78, 0x20, 0x90, 0xCB, 0x88, 0x11, 0x3A, 0x94, 0x65, 0xC0, 0x7C, 0x63,
		0x87, 0xF0, 0x3C, 0xAF, 0xD6, 0x25, 0xE4, 0x8B, 0x38, 0x0A, 0xAC, 0x72, 0x21, 0xD4, 0xF8, 0x07*/
	};
     31e:	de 01       	movw	r26, r28
     320:	11 96       	adiw	r26, 0x01	; 1
     322:	ef e0       	ldi	r30, 0x0F	; 15
     324:	f1 e0       	ldi	r31, 0x01	; 1
     326:	88 e0       	ldi	r24, 0x08	; 8
     328:	01 90       	ld	r0, Z+
     32a:	0d 92       	st	X+, r0
     32c:	81 50       	subi	r24, 0x01	; 1
     32e:	e1 f7       	brne	.-8      	; 0x328 <GetGBAInfo+0x44>
     330:	85 01       	movw	r16, r10
     332:	ff 24       	eor	r15, r15
	
	//Read header
	for(uint8_t i = 0x00;i < 0xC0;i += 2 )
	{
		*ptr = ReadGBABytes(i/2);
     334:	39 e0       	ldi	r19, 0x09	; 9
     336:	83 2e       	mov	r8, r19
     338:	91 2c       	mov	r9, r1
     33a:	8c 0e       	add	r8, r28
     33c:	9d 1e       	adc	r9, r29
		0xBB, 0x3E, 0x03, 0x44, 0x78, 0x20, 0x90, 0xCB, 0x88, 0x11, 0x3A, 0x94, 0x65, 0xC0, 0x7C, 0x63,
		0x87, 0xF0, 0x3C, 0xAF, 0xD6, 0x25, 0xE4, 0x8B, 0x38, 0x0A, 0xAC, 0x72, 0x21, 0xD4, 0xF8, 0x07*/
	};
	
	//Read header
	for(uint8_t i = 0x00;i < 0xC0;i += 2 )
     33e:	2e eb       	ldi	r18, 0xBE	; 190
     340:	c2 2e       	mov	r12, r18
     342:	d1 2c       	mov	r13, r1
     344:	ca 0c       	add	r12, r10
     346:	db 1c       	adc	r13, r11
	{
		*ptr = ReadGBABytes(i/2);
     348:	40 2f       	mov	r20, r16
     34a:	48 19       	sub	r20, r8
     34c:	46 95       	lsr	r20
     34e:	50 e0       	ldi	r21, 0x00	; 0
     350:	60 e0       	ldi	r22, 0x00	; 0
     352:	70 e0       	ldi	r23, 0x00	; 0
     354:	81 e0       	ldi	r24, 0x01	; 1
     356:	93 df       	rcall	.-218    	; 0x27e <_ReadGBABytes>
     358:	d8 01       	movw	r26, r16
     35a:	8d 93       	st	X+, r24
     35c:	9c 93       	st	X, r25
	
		if(*ptr == 0xFFFF)
     35e:	8f 5f       	subi	r24, 0xFF	; 255
     360:	9f 4f       	sbci	r25, 0xFF	; 255
     362:	09 f4       	brne	.+2      	; 0x366 <GetGBAInfo+0x82>
			FF_Cnt++;		
     364:	f3 94       	inc	r15
		if(FF_Cnt >= 3)
     366:	e2 e0       	ldi	r30, 0x02	; 2
     368:	ef 15       	cp	r30, r15
     36a:	c0 f1       	brcs	.+112    	; 0x3dc <GetGBAInfo+0xf8>
		0xBB, 0x3E, 0x03, 0x44, 0x78, 0x20, 0x90, 0xCB, 0x88, 0x11, 0x3A, 0x94, 0x65, 0xC0, 0x7C, 0x63,
		0x87, 0xF0, 0x3C, 0xAF, 0xD6, 0x25, 0xE4, 0x8B, 0x38, 0x0A, 0xAC, 0x72, 0x21, 0xD4, 0xF8, 0x07*/
	};
	
	//Read header
	for(uint8_t i = 0x00;i < 0xC0;i += 2 )
     36c:	0c 15       	cp	r16, r12
     36e:	1d 05       	cpc	r17, r13
     370:	19 f0       	breq	.+6      	; 0x378 <GetGBAInfo+0x94>
		if(*ptr == 0xFFFF)
			FF_Cnt++;		
		if(FF_Cnt >= 3)
			return ERR_FAULT_CART;
		
		ptr++;
     372:	0e 5f       	subi	r16, 0xFE	; 254
     374:	1f 4f       	sbci	r17, 0xFF	; 255
     376:	e8 cf       	rjmp	.-48     	; 0x348 <GetGBAInfo+0x64>
     378:	fe 01       	movw	r30, r28
     37a:	31 96       	adiw	r30, 0x01	; 1
     37c:	de 01       	movw	r26, r28
     37e:	1d 96       	adiw	r26, 0x0d	; 13
	}
	
	//compare logo. we only compare 8 bytes because we are lazy and saving space
	for(uint8_t i = 0x00;i < 0x08;i++)
     380:	9e 01       	movw	r18, r28
     382:	27 5f       	subi	r18, 0xF7	; 247
     384:	3f 4f       	sbci	r19, 0xFF	; 255
	{
		if(Logo[i] != info.Logo[i])
     386:	90 81       	ld	r25, Z
     388:	8c 91       	ld	r24, X
     38a:	98 17       	cp	r25, r24
     38c:	11 f0       	breq	.+4      	; 0x392 <GetGBAInfo+0xae>
     38e:	88 ef       	ldi	r24, 0xF8	; 248
     390:	26 c0       	rjmp	.+76     	; 0x3de <GetGBAInfo+0xfa>
     392:	31 96       	adiw	r30, 0x01	; 1
     394:	11 96       	adiw	r26, 0x01	; 1
		
		ptr++;
	}
	
	//compare logo. we only compare 8 bytes because we are lazy and saving space
	for(uint8_t i = 0x00;i < 0x08;i++)
     396:	e2 17       	cp	r30, r18
     398:	f3 07       	cpc	r31, r19
     39a:	a9 f7       	brne	.-22     	; 0x386 <GetGBAInfo+0xa2>
		if(Logo[i] != info.Logo[i])
			return ERR_LOGO_CHECK;
	}
	
	//compare fixed value
	if(info.FixedValue != 0x96)
     39c:	fe 01       	movw	r30, r28
     39e:	e5 54       	subi	r30, 0x45	; 69
     3a0:	ff 4f       	sbci	r31, 0xFF	; 255
     3a2:	80 81       	ld	r24, Z
     3a4:	86 39       	cpi	r24, 0x96	; 150
     3a6:	d1 f4       	brne	.+52     	; 0x3dc <GetGBAInfo+0xf8>
		return ERR_FAULT_CART;
	
	//eh, it'll be ok. copy over the name...
	memset(name,0,13);
     3a8:	ee 2d       	mov	r30, r14
     3aa:	f7 2d       	mov	r31, r7
     3ac:	8d e0       	ldi	r24, 0x0D	; 13
     3ae:	df 01       	movw	r26, r30
     3b0:	1d 92       	st	X+, r1
     3b2:	8a 95       	dec	r24
     3b4:	e9 f7       	brne	.-6      	; 0x3b0 <GetGBAInfo+0xcc>
	ptr = (uint16_t*)name;
     3b6:	2e 2d       	mov	r18, r14
     3b8:	37 2d       	mov	r19, r7
     3ba:	c9 01       	movw	r24, r18
     3bc:	dc 01       	movw	r26, r24
	uint16_t* ptr_name = (uint16_t*)info.Name;
     3be:	fe 01       	movw	r30, r28
     3c0:	e7 55       	subi	r30, 0x57	; 87
     3c2:	ff 4f       	sbci	r31, 0xFF	; 255
	for(uint8_t i = 0x00;i < 0x0C;i += 2 )
     3c4:	95 01       	movw	r18, r10
     3c6:	24 55       	subi	r18, 0x54	; 84
     3c8:	3f 4f       	sbci	r19, 0xFF	; 255
	{
		*ptr = *ptr_name;
     3ca:	81 91       	ld	r24, Z+
     3cc:	91 91       	ld	r25, Z+
     3ce:	8d 93       	st	X+, r24
     3d0:	9d 93       	st	X+, r25
	
	//eh, it'll be ok. copy over the name...
	memset(name,0,13);
	ptr = (uint16_t*)name;
	uint16_t* ptr_name = (uint16_t*)info.Name;
	for(uint8_t i = 0x00;i < 0x0C;i += 2 )
     3d2:	e2 17       	cp	r30, r18
     3d4:	f3 07       	cpc	r31, r19
     3d6:	c9 f7       	brne	.-14     	; 0x3ca <GetGBAInfo+0xe6>
     3d8:	81 e0       	ldi	r24, 0x01	; 1
     3da:	01 c0       	rjmp	.+2      	; 0x3de <GetGBAInfo+0xfa>
     3dc:	86 ef       	ldi	r24, 0xF6	; 246
		ptr++;
		ptr_name++;
	}

	return 1;
     3de:	c8 53       	subi	r28, 0x38	; 56
     3e0:	df 4f       	sbci	r29, 0xFF	; 255
     3e2:	0f b6       	in	r0, 0x3f	; 63
     3e4:	f8 94       	cli
     3e6:	de bf       	out	0x3e, r29	; 62
     3e8:	0f be       	out	0x3f, r0	; 63
     3ea:	cd bf       	out	0x3d, r28	; 61
     3ec:	cf 91       	pop	r28
     3ee:	df 91       	pop	r29
     3f0:	1f 91       	pop	r17
     3f2:	0f 91       	pop	r16
     3f4:	ff 90       	pop	r15
     3f6:	ef 90       	pop	r14
     3f8:	df 90       	pop	r13
     3fa:	cf 90       	pop	r12
     3fc:	bf 90       	pop	r11
     3fe:	af 90       	pop	r10
     400:	9f 90       	pop	r9
     402:	8f 90       	pop	r8
     404:	7f 90       	pop	r7
     406:	08 95       	ret

00000408 <GetGBARomSize>:
	SetPin(CTRL_PORT,CS1);
	
	return (uint16_t)d1 << 8 | d2;
}
uint32_t GetGBARomSize(void)
{
     408:	2f 92       	push	r2
     40a:	3f 92       	push	r3
     40c:	4f 92       	push	r4
     40e:	5f 92       	push	r5
     410:	6f 92       	push	r6
     412:	7f 92       	push	r7
     414:	8f 92       	push	r8
     416:	9f 92       	push	r9
     418:	af 92       	push	r10
     41a:	bf 92       	push	r11
     41c:	cf 92       	push	r12
     41e:	df 92       	push	r13
     420:	ef 92       	push	r14
     422:	ff 92       	push	r15
     424:	0f 93       	push	r16
     426:	1f 93       	push	r17
     428:	df 93       	push	r29
     42a:	cf 93       	push	r28
     42c:	cd b7       	in	r28, 0x3d	; 61
     42e:	de b7       	in	r29, 0x3e	; 62
     430:	6e 97       	sbiw	r28, 0x1e	; 30
     432:	0f b6       	in	r0, 0x3f	; 63
     434:	f8 94       	cli
     436:	de bf       	out	0x3e, r29	; 62
     438:	0f be       	out	0x3f, r0	; 63
     43a:	cd bf       	out	0x3d, r28	; 61
     43c:	1e 01       	movw	r2, r28
     43e:	08 94       	sec
     440:	21 1c       	adc	r2, r1
     442:	31 1c       	adc	r3, r1
     444:	21 01       	movw	r4, r2
     446:	ee 24       	eor	r14, r14
     448:	ff 24       	eor	r15, r15
     44a:	87 01       	movw	r16, r14
	uint32_t i = 0;
	uint16_t start[0x0F];
	uint8_t endFound = 0;
	
	//retrieve first few bytes of header to use to compare later
	for(uint8_t x = 0;x < 0x0F;x++)
     44c:	7f e1       	ldi	r23, 0x1F	; 31
     44e:	c7 2e       	mov	r12, r23
     450:	d1 2c       	mov	r13, r1
     452:	cc 0e       	add	r12, r28
     454:	dd 1e       	adc	r13, r29
	{
		start[x] = ReadGBABytes(x);
     456:	81 e0       	ldi	r24, 0x01	; 1
     458:	b8 01       	movw	r22, r16
     45a:	a7 01       	movw	r20, r14
     45c:	10 df       	rcall	.-480    	; 0x27e <_ReadGBABytes>
     45e:	f2 01       	movw	r30, r4
     460:	81 93       	st	Z+, r24
     462:	91 93       	st	Z+, r25
     464:	2f 01       	movw	r4, r30
     466:	08 94       	sec
     468:	e1 1c       	adc	r14, r1
     46a:	f1 1c       	adc	r15, r1
     46c:	01 1d       	adc	r16, r1
     46e:	11 1d       	adc	r17, r1
	uint32_t i = 0;
	uint16_t start[0x0F];
	uint8_t endFound = 0;
	
	//retrieve first few bytes of header to use to compare later
	for(uint8_t x = 0;x < 0x0F;x++)
     470:	ec 15       	cp	r30, r12
     472:	fd 05       	cpc	r31, r13
     474:	81 f7       	brne	.-32     	; 0x456 <GetGBARomSize+0x4e>
     476:	e1 2c       	mov	r14, r1
     478:	f1 2c       	mov	r15, r1
     47a:	60 e1       	ldi	r22, 0x10	; 16
     47c:	06 2f       	mov	r16, r22
     47e:	11 2d       	mov	r17, r1
     480:	66 24       	eor	r6, r6
     482:	77 24       	eor	r7, r7
     484:	22 c0       	rjmp	.+68     	; 0x4ca <__stack+0x6b>
	//basically we read all addresses untill we notice the rom starts mirroring. thats our size
	for(i = 0x00100000UL; i <= 0x01000000UL; i<<=1)
	{	
		for(uint8_t x = 0;x < 0x0F;x++)
		{
			if(ReadGBABytes(i+x) != start[x])
     486:	81 e0       	ldi	r24, 0x01	; 1
     488:	b6 01       	movw	r22, r12
     48a:	a5 01       	movw	r20, r10
     48c:	f8 de       	rcall	.-528    	; 0x27e <_ReadGBABytes>
     48e:	f4 01       	movw	r30, r8
     490:	20 81       	ld	r18, Z
     492:	31 81       	ldd	r19, Z+1	; 0x01
     494:	82 17       	cp	r24, r18
     496:	93 07       	cpc	r25, r19
     498:	69 f4       	brne	.+26     	; 0x4b4 <__stack+0x55>
     49a:	08 94       	sec
     49c:	a1 1c       	adc	r10, r1
     49e:	b1 1c       	adc	r11, r1
     4a0:	c1 1c       	adc	r12, r1
     4a2:	d1 1c       	adc	r13, r1
     4a4:	82 e0       	ldi	r24, 0x02	; 2
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	88 0e       	add	r8, r24
     4aa:	99 1e       	adc	r9, r25
	}
	
	//basically we read all addresses untill we notice the rom starts mirroring. thats our size
	for(i = 0x00100000UL; i <= 0x01000000UL; i<<=1)
	{	
		for(uint8_t x = 0;x < 0x0F;x++)
     4ac:	84 14       	cp	r8, r4
     4ae:	95 04       	cpc	r9, r5
     4b0:	51 f7       	brne	.-44     	; 0x486 <__stack+0x27>
     4b2:	0f c0       	rjmp	.+30     	; 0x4d2 <__stack+0x73>
	{
		start[x] = ReadGBABytes(x);
	}
	
	//basically we read all addresses untill we notice the rom starts mirroring. thats our size
	for(i = 0x00100000UL; i <= 0x01000000UL; i<<=1)
     4b4:	ee 0c       	add	r14, r14
     4b6:	ff 1c       	adc	r15, r15
     4b8:	00 1f       	adc	r16, r16
     4ba:	11 1f       	adc	r17, r17
     4bc:	08 94       	sec
     4be:	61 1c       	adc	r6, r1
     4c0:	71 1c       	adc	r7, r1
     4c2:	95 e0       	ldi	r25, 0x05	; 5
     4c4:	69 16       	cp	r6, r25
     4c6:	71 04       	cpc	r7, r1
     4c8:	21 f0       	breq	.+8      	; 0x4d2 <__stack+0x73>
     4ca:	57 01       	movw	r10, r14
     4cc:	68 01       	movw	r12, r16
     4ce:	41 01       	movw	r8, r2
     4d0:	da cf       	rjmp	.-76     	; 0x486 <__stack+0x27>
		}		
		if(endFound)
			break;	
	}
	return i;
}
     4d2:	b7 01       	movw	r22, r14
     4d4:	c8 01       	movw	r24, r16
     4d6:	6e 96       	adiw	r28, 0x1e	; 30
     4d8:	0f b6       	in	r0, 0x3f	; 63
     4da:	f8 94       	cli
     4dc:	de bf       	out	0x3e, r29	; 62
     4de:	0f be       	out	0x3f, r0	; 63
     4e0:	cd bf       	out	0x3d, r28	; 61
     4e2:	cf 91       	pop	r28
     4e4:	df 91       	pop	r29
     4e6:	1f 91       	pop	r17
     4e8:	0f 91       	pop	r16
     4ea:	ff 90       	pop	r15
     4ec:	ef 90       	pop	r14
     4ee:	df 90       	pop	r13
     4f0:	cf 90       	pop	r12
     4f2:	bf 90       	pop	r11
     4f4:	af 90       	pop	r10
     4f6:	9f 90       	pop	r9
     4f8:	8f 90       	pop	r8
     4fa:	7f 90       	pop	r7
     4fc:	6f 90       	pop	r6
     4fe:	5f 90       	pop	r5
     500:	4f 90       	pop	r4
     502:	3f 90       	pop	r3
     504:	2f 90       	pop	r2
     506:	08 95       	ret

00000508 <_ReadGBAIncrementedBytes>:
//The GBA supports something as a increment read.
//basically as long as CS1 is kept low, the next RD strobe will just reveal the next 2 bytes.
//so if you set the address, and read again, you'll get addr+1, next time addr+2 etc etc
//this saves us quiet a few cycles on setting everything.
inline uint16_t _ReadGBAIncrementedBytes(int8_t SetAddress,uint32_t address)
{
     508:	df 93       	push	r29
     50a:	cf 93       	push	r28
     50c:	00 d0       	rcall	.+0      	; 0x50e <_ReadGBAIncrementedBytes+0x6>
     50e:	cd b7       	in	r28, 0x3d	; 61
     510:	de b7       	in	r29, 0x3e	; 62
	uint8_t d1 = 0;
     512:	19 82       	std	Y+1, r1	; 0x01
	uint8_t d2 = 0;
     514:	1a 82       	std	Y+2, r1	; 0x02
		
	SetPin(CTRL_PORT,RD);
     516:	95 9a       	sbi	0x12, 5	; 18
	SetPin(CTRL_PORT,WD);
     518:	96 9a       	sbi	0x12, 6	; 18
	
	if(SetAddress)
     51a:	88 23       	and	r24, r24
     51c:	39 f0       	breq	.+14     	; 0x52c <_ReadGBAIncrementedBytes+0x24>
	{
		//do the whole shabang
		SetPin(CTRL_PORT,CS1);
     51e:	97 9a       	sbi	0x12, 7	; 18
		SetPin(CTRL_PORT,CS2);
     520:	93 9a       	sbi	0x12, 3	; 18
		SetGBAAddress(address);
     522:	cb 01       	movw	r24, r22
     524:	ba 01       	movw	r22, r20
     526:	8b de       	rcall	.-746    	; 0x23e <SetGBAAddress>
		asm("nop");
     528:	00 00       	nop
		ClearPin(CTRL_PORT,CS1);
     52a:	97 98       	cbi	0x12, 7	; 18
	}
	
	ClearPin(CTRL_PORT,RD);
     52c:	95 98       	cbi	0x12, 5	; 18
	
	SetGBADataAsInput();
     52e:	65 de       	rcall	.-822    	; 0x1fa <SetGBADataAsInput>
	
#ifdef GPIO_EXTENDER_MODE			
	//read data
	mcp23008_ReadReg(ADDR_CHIP_1, GPIO,&d1);
     530:	80 e4       	ldi	r24, 0x40	; 64
     532:	69 e0       	ldi	r22, 0x09	; 9
     534:	ae 01       	movw	r20, r28
     536:	4f 5f       	subi	r20, 0xFF	; 255
     538:	5f 4f       	sbci	r21, 0xFF	; 255
     53a:	86 d6       	rcall	.+3340   	; 0x1248 <mcp23008_ReadReg>
	mcp23008_ReadReg(ADDR_CHIP_2, GPIO,&d2);	
     53c:	82 e4       	ldi	r24, 0x42	; 66
     53e:	69 e0       	ldi	r22, 0x09	; 9
     540:	ae 01       	movw	r20, r28
     542:	4e 5f       	subi	r20, 0xFE	; 254
     544:	5f 4f       	sbci	r21, 0xFF	; 255
     546:	80 d6       	rcall	.+3328   	; 0x1248 <mcp23008_ReadReg>
#endif
	
	SetPin(CTRL_PORT,RD);
     548:	95 9a       	sbi	0x12, 5	; 18
     54a:	99 81       	ldd	r25, Y+1	; 0x01
     54c:	80 e0       	ldi	r24, 0x00	; 0
     54e:	2a 81       	ldd	r18, Y+2	; 0x02
     550:	30 e0       	ldi	r19, 0x00	; 0
     552:	28 2b       	or	r18, r24
     554:	39 2b       	or	r19, r25
	return (uint16_t)d1 << 8 | d2;
}
     556:	c9 01       	movw	r24, r18
     558:	0f 90       	pop	r0
     55a:	0f 90       	pop	r0
     55c:	cf 91       	pop	r28
     55e:	df 91       	pop	r29
     560:	08 95       	ret

00000562 <Setup_GBA_Pins>:
}
void Setup_GBA_Pins(void)
{
#ifdef GPIO_EXTENDER_MODE
	//setup the mcp23008, as its the source of everything xD
	mcp23008_init(ADDR_CHIP_1);
     562:	80 e4       	ldi	r24, 0x40	; 64
     564:	8e d6       	rcall	.+3356   	; 0x1282 <mcp23008_init>
	mcp23008_init(ADDR_CHIP_2);
     566:	82 e4       	ldi	r24, 0x42	; 66
     568:	8c d6       	rcall	.+3352   	; 0x1282 <mcp23008_init>
	mcp23008_init(DATA_CHIP_1);
     56a:	84 e4       	ldi	r24, 0x44	; 68
     56c:	8a d6       	rcall	.+3348   	; 0x1282 <mcp23008_init>

	SetGBADataAsOutput();	
     56e:	56 de       	rcall	.-852    	; 0x21c <SetGBADataAsOutput>
#endif	

	//setup data pins as input
	SetDataPinsAsInput(); 
     570:	d7 d0       	rcall	.+430    	; 0x720 <SetDataPinsAsInput>
	
	//setup D pins as well for the other, as output
	CTRL_DDR |= ( (0 << BTN) | (1 << RD) | (1 << WD) | (1 << CS1) | (1 << CS2) );//0b01111100;
     572:	81 b3       	in	r24, 0x11	; 17
     574:	88 6e       	ori	r24, 0xE8	; 232
     576:	81 bb       	out	0x11, r24	; 17
	//FUCK TRISTATE BULLSHIT xD set the mode of the pins correctly!
	CTRL_PORT |= ((1 << BTN) | (1 << RD) | (1 << WD) | (1 << CS1) | (1 << CS2) ); //0b01111100;
     578:	82 b3       	in	r24, 0x12	; 18
     57a:	88 6f       	ori	r24, 0xF8	; 248
     57c:	82 bb       	out	0x12, r24	; 18
	
	SetPin(CTRL_PORT,WD);
     57e:	96 9a       	sbi	0x12, 6	; 18
	SetPin(CTRL_PORT,RD);
     580:	95 9a       	sbi	0x12, 5	; 18
	SetPin(CTRL_PORT,CS1);
     582:	97 9a       	sbi	0x12, 7	; 18
	SetPin(CTRL_PORT,CS2);
     584:	93 9a       	sbi	0x12, 3	; 18
}
     586:	08 95       	ret

00000588 <_setPin>:
#endif

//the Barebone functions
//--------------------------------
inline void _setPin(volatile uint8_t *port,uint8_t mask)
{
     588:	fc 01       	movw	r30, r24
	*port |= mask;
     58a:	80 81       	ld	r24, Z
     58c:	86 2b       	or	r24, r22
     58e:	80 83       	st	Z, r24
}
     590:	08 95       	ret

00000592 <_clearPin>:
inline void _clearPin(volatile uint8_t *port,uint8_t mask)
{
     592:	fc 01       	movw	r30, r24
	*port &= ~mask;
     594:	80 81       	ld	r24, Z
     596:	60 95       	com	r22
     598:	86 23       	and	r24, r22
     59a:	80 83       	st	Z, r24
}
     59c:	08 95       	ret

0000059e <SetControlPin>:
inline void SetControlPin(uint8_t Pin,uint8_t state)
{
     59e:	38 2f       	mov	r19, r24
	if(state > 0)
     5a0:	66 23       	and	r22, r22
     5a2:	59 f0       	breq	.+22     	; 0x5ba <SetControlPin+0x1c>
	{
		SetPin(CTRL_PORT,Pin); // pin goes high
     5a4:	22 b3       	in	r18, 0x12	; 18
     5a6:	81 e0       	ldi	r24, 0x01	; 1
     5a8:	90 e0       	ldi	r25, 0x00	; 0
     5aa:	02 c0       	rjmp	.+4      	; 0x5b0 <SetControlPin+0x12>
     5ac:	88 0f       	add	r24, r24
     5ae:	99 1f       	adc	r25, r25
     5b0:	3a 95       	dec	r19
     5b2:	e2 f7       	brpl	.-8      	; 0x5ac <SetControlPin+0xe>
     5b4:	28 2b       	or	r18, r24
     5b6:	22 bb       	out	0x12, r18	; 18
     5b8:	08 95       	ret
	}	
	else
	{
		ClearPin(CTRL_PORT,Pin); // Pin goes low
     5ba:	22 b3       	in	r18, 0x12	; 18
     5bc:	81 e0       	ldi	r24, 0x01	; 1
     5be:	90 e0       	ldi	r25, 0x00	; 0
     5c0:	02 c0       	rjmp	.+4      	; 0x5c6 <SetControlPin+0x28>
     5c2:	88 0f       	add	r24, r24
     5c4:	99 1f       	adc	r25, r25
     5c6:	3a 95       	dec	r19
     5c8:	e2 f7       	brpl	.-8      	; 0x5c2 <SetControlPin+0x24>
     5ca:	80 95       	com	r24
     5cc:	82 23       	and	r24, r18
     5ce:	82 bb       	out	0x12, r24	; 18
     5d0:	08 95       	ret

000005d2 <CheckControlPin>:
	//asm ("nop");
	
}
int8_t CheckControlPin(uint8_t Pin)
{
	if((CTRL_PIN & (1<< Pin)) == 0)
     5d2:	20 b3       	in	r18, 0x10	; 16
     5d4:	30 e0       	ldi	r19, 0x00	; 0
     5d6:	02 c0       	rjmp	.+4      	; 0x5dc <CheckControlPin+0xa>
     5d8:	35 95       	asr	r19
     5da:	27 95       	ror	r18
     5dc:	8a 95       	dec	r24
     5de:	e2 f7       	brpl	.-8      	; 0x5d8 <CheckControlPin+0x6>
		return LOW;
	return HIGH;
}
     5e0:	82 2f       	mov	r24, r18
     5e2:	81 70       	andi	r24, 0x01	; 1
     5e4:	08 95       	ret

000005e6 <GetRomBanks>:
	
	return 1;	
}
uint16_t GetRomBanks(uint8_t RomSizeFlag)
{
	if(RomSizeFlag > 7)
     5e6:	88 30       	cpi	r24, 0x08	; 8
     5e8:	98 f0       	brcs	.+38     	; 0x610 <GetRomBanks+0x2a>
	{
		switch(RomSizeFlag)
     5ea:	85 33       	cpi	r24, 0x35	; 53
     5ec:	29 f0       	breq	.+10     	; 0x5f8 <GetRomBanks+0x12>
     5ee:	86 33       	cpi	r24, 0x36	; 54
     5f0:	49 f0       	breq	.+18     	; 0x604 <GetRomBanks+0x1e>
     5f2:	84 33       	cpi	r24, 0x34	; 52
     5f4:	51 f4       	brne	.+20     	; 0x60a <GetRomBanks+0x24>
     5f6:	03 c0       	rjmp	.+6      	; 0x5fe <GetRomBanks+0x18>
     5f8:	20 e5       	ldi	r18, 0x50	; 80
     5fa:	30 e0       	ldi	r19, 0x00	; 0
     5fc:	10 c0       	rjmp	.+32     	; 0x61e <GetRomBanks+0x38>
     5fe:	28 e4       	ldi	r18, 0x48	; 72
     600:	30 e0       	ldi	r19, 0x00	; 0
     602:	0d c0       	rjmp	.+26     	; 0x61e <GetRomBanks+0x38>
     604:	20 e6       	ldi	r18, 0x60	; 96
     606:	30 e0       	ldi	r19, 0x00	; 0
     608:	0a c0       	rjmp	.+20     	; 0x61e <GetRomBanks+0x38>
			case 52:
				return 72;
			case 53:
				return 80;
			case 54: 
				return 96;
     60a:	21 e0       	ldi	r18, 0x01	; 1
     60c:	30 e0       	ldi	r19, 0x00	; 0
     60e:	07 c0       	rjmp	.+14     	; 0x61e <GetRomBanks+0x38>
				return 1;
		}
	}
	else
	{
		return 2 << RomSizeFlag;
     610:	22 e0       	ldi	r18, 0x02	; 2
     612:	30 e0       	ldi	r19, 0x00	; 0
     614:	02 c0       	rjmp	.+4      	; 0x61a <GetRomBanks+0x34>
     616:	22 0f       	add	r18, r18
     618:	33 1f       	adc	r19, r19
     61a:	8a 95       	dec	r24
     61c:	e2 f7       	brpl	.-8      	; 0x616 <GetRomBanks+0x30>
	}
}
     61e:	c9 01       	movw	r24, r18
     620:	08 95       	ret

00000622 <GetRamDetails>:
int8_t GetRamDetails(uint16_t *end_addr, uint8_t *banks,uint8_t RamSize)
{
     622:	dc 01       	movw	r26, r24
     624:	fb 01       	movw	r30, r22
	if(end_addr == NULL || banks == NULL)
     626:	00 97       	sbiw	r24, 0x00	; 0
     628:	a1 f1       	breq	.+104    	; 0x692 <GetRamDetails+0x70>
     62a:	61 15       	cp	r22, r1
     62c:	71 05       	cpc	r23, r1
     62e:	89 f1       	breq	.+98     	; 0x692 <GetRamDetails+0x70>
		return ERR_MBC_SAVE_UNSUPPORTED;
	
	//every MBC type has ramsize as the amount of banks
	//...except MBC2 which needs ramsize to be set to 0, because its RAM is included in MBC2
	if(LoadedBankType != MBC2 && RamSize <= 0)
     630:	80 91 65 01 	lds	r24, 0x0165
     634:	80 32       	cpi	r24, 0x20	; 32
     636:	21 f0       	breq	.+8      	; 0x640 <GetRamDetails+0x1e>
     638:	44 23       	and	r20, r20
     63a:	39 f4       	brne	.+14     	; 0x64a <GetRamDetails+0x28>
     63c:	87 ef       	ldi	r24, 0xF7	; 247
     63e:	08 95       	ret
	}
	
	if(LoadedBankType == MBC2)
	{		
		//Set the Ram Size & end addr. MBC2 is euh...special :P
		*banks = 1;
     640:	81 e0       	ldi	r24, 0x01	; 1
     642:	80 83       	st	Z, r24
		*end_addr = 0xA200;
     644:	80 e0       	ldi	r24, 0x00	; 0
     646:	92 ea       	ldi	r25, 0xA2	; 162
     648:	16 c0       	rjmp	.+44     	; 0x676 <GetRamDetails+0x54>
	}
	else
	{
		*end_addr = 0xC000;
     64a:	80 e0       	ldi	r24, 0x00	; 0
     64c:	90 ec       	ldi	r25, 0xC0	; 192
     64e:	11 96       	adiw	r26, 0x01	; 1
     650:	9c 93       	st	X, r25
     652:	8e 93       	st	-X, r24
		switch(RamSize)
     654:	43 30       	cpi	r20, 0x03	; 3
     656:	a9 f0       	breq	.+42     	; 0x682 <GetRamDetails+0x60>
     658:	44 30       	cpi	r20, 0x04	; 4
     65a:	28 f4       	brcc	.+10     	; 0x666 <GetRamDetails+0x44>
     65c:	41 30       	cpi	r20, 0x01	; 1
     65e:	41 f0       	breq	.+16     	; 0x670 <GetRamDetails+0x4e>
     660:	42 30       	cpi	r20, 0x02	; 2
     662:	b9 f4       	brne	.+46     	; 0x692 <GetRamDetails+0x70>
     664:	0b c0       	rjmp	.+22     	; 0x67c <GetRamDetails+0x5a>
     666:	44 30       	cpi	r20, 0x04	; 4
     668:	71 f0       	breq	.+28     	; 0x686 <GetRamDetails+0x64>
     66a:	45 30       	cpi	r20, 0x05	; 5
     66c:	91 f4       	brne	.+36     	; 0x692 <GetRamDetails+0x70>
     66e:	0d c0       	rjmp	.+26     	; 0x68a <GetRamDetails+0x68>
		{
			case 0x01: //1 bank of 2KB ram
				*banks = 1;
     670:	40 83       	st	Z, r20
				*end_addr = 0xA800;
     672:	80 e0       	ldi	r24, 0x00	; 0
     674:	98 ea       	ldi	r25, 0xA8	; 168
     676:	8d 93       	st	X+, r24
     678:	9c 93       	st	X, r25
     67a:	09 c0       	rjmp	.+18     	; 0x68e <GetRamDetails+0x6c>
				break;
			case 0x02: //1 bank of 8KB ram
				*banks = 1;
     67c:	81 e0       	ldi	r24, 0x01	; 1
     67e:	80 83       	st	Z, r24
     680:	08 95       	ret
				break;
			case 0x03: //4 banks, 32KB
				*banks = 4;
     682:	84 e0       	ldi	r24, 0x04	; 4
     684:	03 c0       	rjmp	.+6      	; 0x68c <GetRamDetails+0x6a>
				break;
			//these are undocumented to the wiki and the pdf 
			//but insidegaget had it in his source so euh... ok...
			case 0x04: //16 banks, 128KB said to be the gameboy camera
				*banks = 16;
     686:	80 e1       	ldi	r24, 0x10	; 16
     688:	01 c0       	rjmp	.+2      	; 0x68c <GetRamDetails+0x6a>
				break;
			case 0x05: //8 banks, 64KB
				*banks = 8;
     68a:	88 e0       	ldi	r24, 0x08	; 8
     68c:	80 83       	st	Z, r24
     68e:	81 e0       	ldi	r24, 0x01	; 1
     690:	08 95       	ret
				break;
     692:	8a ee       	ldi	r24, 0xEA	; 234
				return ERR_MBC_SAVE_UNSUPPORTED;
				break;
		}
	}
	return 1;
}
     694:	08 95       	ret

00000696 <GetMBCType>:
uint8_t GetMBCType(uint8_t CartType)
{
	uint8_t ret = MBC_NONE;
	
	switch(CartType)
     696:	8e 30       	cpi	r24, 0x0E	; 14
     698:	78 f4       	brcc	.+30     	; 0x6b8 <GetMBCType+0x22>
     69a:	8b 30       	cpi	r24, 0x0B	; 11
     69c:	10 f5       	brcc	.+68     	; 0x6e2 <GetMBCType+0x4c>
     69e:	87 30       	cpi	r24, 0x07	; 7
     6a0:	38 f4       	brcc	.+14     	; 0x6b0 <GetMBCType+0x1a>
     6a2:	85 30       	cpi	r24, 0x05	; 5
     6a4:	d0 f4       	brcc	.+52     	; 0x6da <GetMBCType+0x44>
     6a6:	88 23       	and	r24, r24
     6a8:	11 f1       	breq	.+68     	; 0x6ee <GetMBCType+0x58>
     6aa:	84 30       	cpi	r24, 0x04	; 4
     6ac:	10 f5       	brcc	.+68     	; 0x6f2 <GetMBCType+0x5c>
     6ae:	17 c0       	rjmp	.+46     	; 0x6de <GetMBCType+0x48>
     6b0:	88 50       	subi	r24, 0x08	; 8
     6b2:	82 30       	cpi	r24, 0x02	; 2
     6b4:	f0 f4       	brcc	.+60     	; 0x6f2 <GetMBCType+0x5c>
     6b6:	15 c0       	rjmp	.+42     	; 0x6e2 <GetMBCType+0x4c>
     6b8:	8f 31       	cpi	r24, 0x1F	; 31
     6ba:	50 f4       	brcc	.+20     	; 0x6d0 <GetMBCType+0x3a>
     6bc:	89 31       	cpi	r24, 0x19	; 25
     6be:	a8 f4       	brcc	.+42     	; 0x6ea <GetMBCType+0x54>
     6c0:	8f 30       	cpi	r24, 0x0F	; 15
     6c2:	b8 f0       	brcs	.+46     	; 0x6f2 <GetMBCType+0x5c>
     6c4:	84 31       	cpi	r24, 0x14	; 20
     6c6:	68 f0       	brcs	.+26     	; 0x6e2 <GetMBCType+0x4c>
     6c8:	85 51       	subi	r24, 0x15	; 21
     6ca:	83 30       	cpi	r24, 0x03	; 3
     6cc:	90 f4       	brcc	.+36     	; 0x6f2 <GetMBCType+0x5c>
     6ce:	0b c0       	rjmp	.+22     	; 0x6e6 <GetMBCType+0x50>
     6d0:	8c 3f       	cpi	r24, 0xFC	; 252
     6d2:	78 f0       	brcs	.+30     	; 0x6f2 <GetMBCType+0x5c>
     6d4:	8f 3f       	cpi	r24, 0xFF	; 255
     6d6:	28 f0       	brcs	.+10     	; 0x6e2 <GetMBCType+0x4c>
     6d8:	02 c0       	rjmp	.+4      	; 0x6de <GetMBCType+0x48>
     6da:	80 e2       	ldi	r24, 0x20	; 32
     6dc:	08 95       	ret
     6de:	80 e1       	ldi	r24, 0x10	; 16
     6e0:	08 95       	ret
     6e2:	80 e3       	ldi	r24, 0x30	; 48
     6e4:	08 95       	ret
		case 0x10: //MBC3 + TIMER + RAM + BATTERY
		case 0x11: //MBC3
		case 0x12: //MBC3 + RAM
		case 0x13: //MBC3 + RAM + BATTERY
			ret = MBC3;
			break;
     6e6:	80 e4       	ldi	r24, 0x40	; 64
     6e8:	08 95       	ret
		
		case 0x15: //MBC4
		case 0x16: //MBC4 + RAM
		case 0x17: //MBC4 + RAM + BATTERY
			ret = MBC4;
			break;
     6ea:	80 e5       	ldi	r24, 0x50	; 80
     6ec:	08 95       	ret
		case 0x1B: //MBC5 + RAM + BATTERY
		case 0x1C: //MBC5 + RUMBLE
		case 0x1D: //MBC5 + RUMBLE + RAM
		case 0x1E: //MBC5 + RUMBLE + RAM + BATTERY
			ret = MBC5;
			break;
     6ee:	89 e0       	ldi	r24, 0x09	; 9
     6f0:	08 95       	ret
		
		case 0x00:
			ret = MBC_NONE;
			break;
     6f2:	80 e0       	ldi	r24, 0x00	; 0
			ret = MBC_UNSUPPORTED;
			break;	
	}
	
	return ret;
     6f4:	08 95       	ret

000006f6 <SetAddress>:
	SetPin(CTRL_PORT,RD);
	SetPin(CTRL_PORT,CS1);
	SetPin(CTRL_PORT,CS2);
}
inline void SetAddress(uint16_t address)
{	
     6f6:	1f 93       	push	r17
     6f8:	48 2f       	mov	r20, r24
     6fa:	19 2f       	mov	r17, r25
	//setup should've set the pins correctly for GB transfer soooo...
	/*mcp23008_WriteReg(ADDR_CHIP_1,IODIR,0x00);
	mcp23008_WriteReg(ADDR_CHIP_2,IODIR,0x00);*/
	
	//write lower address
	mcp23008_WriteReg(ADDR_CHIP_2,GPIO,(uint8_t)(address & 0xFF));
     6fc:	82 e4       	ldi	r24, 0x42	; 66
     6fe:	69 e0       	ldi	r22, 0x09	; 9
     700:	8f d5       	rcall	.+2846   	; 0x1220 <mcp23008_WriteReg>
	
	//write upper address
	mcp23008_WriteReg(ADDR_CHIP_1,GPIO,address >> 8);
     702:	80 e4       	ldi	r24, 0x40	; 64
     704:	69 e0       	ldi	r22, 0x09	; 9
     706:	41 2f       	mov	r20, r17
     708:	8b d5       	rcall	.+2838   	; 0x1220 <mcp23008_WriteReg>
	uint8_t adr2 = (uint8_t)(address & 0xFF);
	
	ADDR_PORT1 = adr1;
	ADDR_PORT2 = adr2;
#endif
}
     70a:	1f 91       	pop	r17
     70c:	08 95       	ret

0000070e <SetDataPinsAsOutput>:
inline void SetDataPinsAsOutput(void)
{
	//set as output
#ifdef GPIO_EXTENDER_MODE
	//disable pull ups
	mcp23008_WriteReg(DATA_CHIP_1,GPPU,0x00);
     70e:	84 e4       	ldi	r24, 0x44	; 68
     710:	66 e0       	ldi	r22, 0x06	; 6
     712:	40 e0       	ldi	r20, 0x00	; 0
     714:	85 d5       	rcall	.+2826   	; 0x1220 <mcp23008_WriteReg>
	
	//set output
	mcp23008_WriteReg(DATA_CHIP_1,IODIR,0x00);	
     716:	84 e4       	ldi	r24, 0x44	; 68
     718:	60 e0       	ldi	r22, 0x00	; 0
     71a:	40 e0       	ldi	r20, 0x00	; 0
     71c:	81 d5       	rcall	.+2818   	; 0x1220 <mcp23008_WriteReg>
#else
	DATA_DDR |= (0xFF);//0b11111111;
	//set output as 0x00
	DATA_PORT = 0x00;
#endif
}
     71e:	08 95       	ret

00000720 <SetDataPinsAsInput>:
}
inline void SetDataPinsAsInput(void)
{
	//set as input;
#ifdef GPIO_EXTENDER_MODE	
	mcp23008_WriteReg(DATA_CHIP_1,IODIR,0xFF);
     720:	84 e4       	ldi	r24, 0x44	; 68
     722:	60 e0       	ldi	r22, 0x00	; 0
     724:	4f ef       	ldi	r20, 0xFF	; 255
     726:	7c d5       	rcall	.+2808   	; 0x1220 <mcp23008_WriteReg>
	
	//enable pull up
	mcp23008_WriteReg(DATA_CHIP_1,GPPU,0xFF);
     728:	84 e4       	ldi	r24, 0x44	; 68
     72a:	66 e0       	ldi	r22, 0x06	; 6
     72c:	4f ef       	ldi	r20, 0xFF	; 255
     72e:	78 d5       	rcall	.+2800   	; 0x1220 <mcp23008_WriteReg>
	DATA_DDR &= ~(0xFF); //0b00000000;
	//enable pull up resistors
	DATA_PORT = 0xFF;
#endif
	return;
}
     730:	08 95       	ret

00000732 <_WriteByte>:
		return ret;
	}
	
}
inline void _WriteByte(int8_t writeRom, uint16_t addr,uint8_t byte)
{
     732:	ef 92       	push	r14
     734:	ff 92       	push	r15
     736:	0f 93       	push	r16
     738:	1f 93       	push	r17
     73a:	e8 2e       	mov	r14, r24
     73c:	8b 01       	movw	r16, r22
     73e:	f4 2e       	mov	r15, r20
	SetPin(CTRL_PORT,WD);
     740:	96 9a       	sbi	0x12, 6	; 18
	SetPin(CTRL_PORT,RD);
     742:	95 9a       	sbi	0x12, 5	; 18
	
	SetDataPinsAsOutput(); 
     744:	e4 df       	rcall	.-56     	; 0x70e <SetDataPinsAsOutput>
	SET_DATA(byte);
     746:	84 e4       	ldi	r24, 0x44	; 68
     748:	69 e0       	ldi	r22, 0x09	; 9
     74a:	4f 2d       	mov	r20, r15
     74c:	69 d5       	rcall	.+2770   	; 0x1220 <mcp23008_WriteReg>
	SetAddress(addr);
     74e:	c8 01       	movw	r24, r16
     750:	d2 df       	rcall	.-92     	; 0x6f6 <SetAddress>
	
	//set Sram control pin low. we do this -AFTER- address is set because MBC2 latches to the address as soon as CS1 is set low. 
	//making the SetAddress do nothing, it'll latch to the address it was set before the SetAddress
	if(writeRom <= 0)
     752:	1e 14       	cp	r1, r14
     754:	0c f0       	brlt	.+2      	; 0x758 <_WriteByte+0x26>
		ClearPin(CTRL_PORT,CS1);
     756:	97 98       	cbi	0x12, 7	; 18
	
	ClearPin(CTRL_PORT,WD);
     758:	96 98       	cbi	0x12, 6	; 18
	
	SetPin(CTRL_PORT,WD);
     75a:	96 9a       	sbi	0x12, 6	; 18
	if(writeRom <= 0)
     75c:	1e 14       	cp	r1, r14
     75e:	0c f0       	brlt	.+2      	; 0x762 <_WriteByte+0x30>
		SetPin(CTRL_PORT,CS1);
     760:	97 9a       	sbi	0x12, 7	; 18
	
	SET_DATA(0x00);
     762:	84 e4       	ldi	r24, 0x44	; 68
     764:	69 e0       	ldi	r22, 0x09	; 9
     766:	40 e0       	ldi	r20, 0x00	; 0
     768:	5b d5       	rcall	.+2742   	; 0x1220 <mcp23008_WriteReg>
	SetDataPinsAsInput();
     76a:	da df       	rcall	.-76     	; 0x720 <SetDataPinsAsInput>
	
	return;
}
     76c:	1f 91       	pop	r17
     76e:	0f 91       	pop	r16
     770:	ff 90       	pop	r15
     772:	ef 90       	pop	r14
     774:	08 95       	ret

00000776 <SwitchRAMBank>:
	}

	return;
}
void SwitchRAMBank(int8_t bank)
{
     776:	48 2f       	mov	r20, r24
	WriteByte(0x4000,bank);	
     778:	81 e0       	ldi	r24, 0x01	; 1
     77a:	60 e0       	ldi	r22, 0x00	; 0
     77c:	70 e4       	ldi	r23, 0x40	; 64
     77e:	d9 df       	rcall	.-78     	; 0x732 <_WriteByte>
	return;
}
     780:	08 95       	ret

00000782 <SwitchROMBank>:
	WriteByte(0x0000,0x00);

	return;
}
void SwitchROMBank(int8_t bank)
{	
     782:	1f 93       	push	r17
     784:	cf 93       	push	r28
     786:	df 93       	push	r29
     788:	18 2f       	mov	r17, r24
	uint8_t Bank_Type = LoadedBankType;
     78a:	80 91 65 01 	lds	r24, 0x0165
	
	if(Bank_Type == MBC_NONE)
     78e:	89 30       	cpi	r24, 0x09	; 9
     790:	b9 f1       	breq	.+110    	; 0x800 <SwitchROMBank+0x7e>

	//first some preperations
	uint16_t addr = 0x2100;
	uint16_t addr2 = 0x4000;
	 
	if(Bank_Type == MBC1)
     792:	80 31       	cpi	r24, 0x10	; 16
     794:	19 f4       	brne	.+6      	; 0x79c <SwitchROMBank+0x1a>
     796:	60 e0       	ldi	r22, 0x00	; 0
     798:	70 e2       	ldi	r23, 0x20	; 32
     79a:	0d c0       	rjmp	.+26     	; 0x7b6 <SwitchROMBank+0x34>
		addr = 0x2000;
	else if(Bank_Type == MBC5)
     79c:	80 35       	cpi	r24, 0x50	; 80
     79e:	19 f4       	brne	.+6      	; 0x7a6 <SwitchROMBank+0x24>
     7a0:	c0 e0       	ldi	r28, 0x00	; 0
     7a2:	d0 e3       	ldi	r29, 0x30	; 48
     7a4:	19 c0       	rjmp	.+50     	; 0x7d8 <SwitchROMBank+0x56>
		addr2 = 0x3000;
	
	switch(Bank_Type)
     7a6:	80 32       	cpi	r24, 0x20	; 32
     7a8:	99 f0       	breq	.+38     	; 0x7d0 <SwitchROMBank+0x4e>
     7aa:	80 35       	cpi	r24, 0x50	; 80
     7ac:	99 f0       	breq	.+38     	; 0x7d4 <SwitchROMBank+0x52>
     7ae:	80 31       	cpi	r24, 0x10	; 16
     7b0:	11 f5       	brne	.+68     	; 0x7f6 <SwitchROMBank+0x74>
     7b2:	60 e0       	ldi	r22, 0x00	; 0
     7b4:	71 e2       	ldi	r23, 0x21	; 33
	{
		case MBC1:
			//in MBC1 we need to 
			// - set 0x6000 in rom mode 
			//WriteByte(0x6000,0);
			WriteByte(addr,bank & 0x1F);
     7b6:	41 2f       	mov	r20, r17
     7b8:	4f 71       	andi	r20, 0x1F	; 31
     7ba:	81 e0       	ldi	r24, 0x01	; 1
     7bc:	ba df       	rcall	.-140    	; 0x732 <_WriteByte>
			WriteByte(addr2,bank >> 5);
     7be:	15 95       	asr	r17
     7c0:	15 95       	asr	r17
     7c2:	15 95       	asr	r17
     7c4:	15 95       	asr	r17
     7c6:	15 95       	asr	r17
     7c8:	81 e0       	ldi	r24, 0x01	; 1
     7ca:	60 e0       	ldi	r22, 0x00	; 0
     7cc:	70 e4       	ldi	r23, 0x40	; 64
     7ce:	16 c0       	rjmp	.+44     	; 0x7fc <SwitchROMBank+0x7a>
			break;
		case MBC2:
			WriteByte(addr,bank & 0x1F);
     7d0:	1f 71       	andi	r17, 0x1F	; 31
     7d2:	11 c0       	rjmp	.+34     	; 0x7f6 <SwitchROMBank+0x74>
			break;
     7d4:	c0 e0       	ldi	r28, 0x00	; 0
     7d6:	d0 e4       	ldi	r29, 0x40	; 64
		case MBC5:
			WriteByte(addr,bank & 0xFF);
     7d8:	81 e0       	ldi	r24, 0x01	; 1
     7da:	60 e0       	ldi	r22, 0x00	; 0
     7dc:	71 e2       	ldi	r23, 0x21	; 33
     7de:	41 2f       	mov	r20, r17
     7e0:	a8 df       	rcall	.-176    	; 0x732 <_WriteByte>
			WriteByte(addr2,bank >> 8);
     7e2:	41 2f       	mov	r20, r17
     7e4:	55 27       	eor	r21, r21
     7e6:	47 fd       	sbrc	r20, 7
     7e8:	50 95       	com	r21
     7ea:	45 2f       	mov	r20, r21
     7ec:	55 0f       	add	r21, r21
     7ee:	55 0b       	sbc	r21, r21
     7f0:	81 e0       	ldi	r24, 0x01	; 1
     7f2:	be 01       	movw	r22, r28
     7f4:	04 c0       	rjmp	.+8      	; 0x7fe <SwitchROMBank+0x7c>
			break;
		default:
		case MBC3:
			WriteByte(addr,bank);
     7f6:	81 e0       	ldi	r24, 0x01	; 1
     7f8:	60 e0       	ldi	r22, 0x00	; 0
     7fa:	71 e2       	ldi	r23, 0x21	; 33
     7fc:	41 2f       	mov	r20, r17
     7fe:	99 df       	rcall	.-206    	; 0x732 <_WriteByte>
			break;
	}

	return;
}
     800:	df 91       	pop	r29
     802:	cf 91       	pop	r28
     804:	1f 91       	pop	r17
     806:	08 95       	ret

00000808 <CloseRam>:
}
void CloseRam(void)
{	
	uint8_t Bank_Type = LoadedBankType;
	//disable RAM again - VERY IMPORTANT -
	if(Bank_Type == MBC1)
     808:	80 91 65 01 	lds	r24, 0x0165
     80c:	80 31       	cpi	r24, 0x10	; 16
     80e:	29 f4       	brne	.+10     	; 0x81a <CloseRam+0x12>
		WriteByte(0x6000,0x00);
     810:	81 e0       	ldi	r24, 0x01	; 1
     812:	60 e0       	ldi	r22, 0x00	; 0
     814:	70 e6       	ldi	r23, 0x60	; 96
     816:	40 e0       	ldi	r20, 0x00	; 0
     818:	8c df       	rcall	.-232    	; 0x732 <_WriteByte>
		
	//uint16_t init_addr = 0x0000;
	WriteByte(0x0000,0x00);
     81a:	81 e0       	ldi	r24, 0x01	; 1
     81c:	60 e0       	ldi	r22, 0x00	; 0
     81e:	70 e0       	ldi	r23, 0x00	; 0
     820:	40 e0       	ldi	r20, 0x00	; 0
     822:	87 df       	rcall	.-242    	; 0x732 <_WriteByte>

	return;
}
     824:	08 95       	ret

00000826 <WriteRAMByte>:
	SetDataPinsAsInput();
	
	return;
}
int8_t WriteRAMByte(uint16_t addr,uint8_t byte)
{
     826:	9c 01       	movw	r18, r24
     828:	46 2f       	mov	r20, r22

	if(LoadedBankType == MBC_NONE || LoadedBankType == MBC_UNSUPPORTED)
     82a:	80 91 65 01 	lds	r24, 0x0165
     82e:	89 30       	cpi	r24, 0x09	; 9
     830:	39 f0       	breq	.+14     	; 0x840 <WriteRAMByte+0x1a>
     832:	88 23       	and	r24, r24
     834:	29 f0       	breq	.+10     	; 0x840 <WriteRAMByte+0x1a>
		return ERR_NO_MBC;
		
	_WriteByte(0,addr,byte);
     836:	80 e0       	ldi	r24, 0x00	; 0
     838:	b9 01       	movw	r22, r18
     83a:	7b df       	rcall	.-266    	; 0x732 <_WriteByte>
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	08 95       	ret
	return 1;
     840:	8c ee       	ldi	r24, 0xEC	; 236
}
     842:	08 95       	ret

00000844 <_ReadByte>:
	ADDR_PORT1 = adr1;
	ADDR_PORT2 = adr2;
#endif
}
inline uint8_t _ReadByte(int8_t ReadRom, uint16_t address)
{
     844:	1f 93       	push	r17
     846:	df 93       	push	r29
     848:	cf 93       	push	r28
     84a:	0f 92       	push	r0
     84c:	cd b7       	in	r28, 0x3d	; 61
     84e:	de b7       	in	r29, 0x3e	; 62
     850:	18 2f       	mov	r17, r24
     852:	cb 01       	movw	r24, r22
	uint8_t data = 0;
     854:	19 82       	std	Y+1, r1	; 0x01

	SetPin(CTRL_PORT,WD);
     856:	96 9a       	sbi	0x12, 6	; 18
	SetPin(CTRL_PORT,RD);
     858:	95 9a       	sbi	0x12, 5	; 18
		
	//pass Address to cartridge via the address bus
	SetAddress(address);
     85a:	4d df       	rcall	.-358    	; 0x6f6 <SetAddress>
	
	//set Sram control pin low. we do this -AFTER- address is set because MBC2 latches to the address as soon as CS1 is set low. 
	//making the SetAddress do nothing, it'll latch to the address it was set before the SetAddress
	if(ReadRom == 0)
     85c:	11 23       	and	r17, r17
     85e:	09 f4       	brne	.+2      	; 0x862 <_ReadByte+0x1e>
	{
		ClearPin(CTRL_PORT,CS1);
     860:	97 98       	cbi	0x12, 7	; 18
	}
	
	//set cartridge in read mode
	ClearPin(CTRL_PORT,RD);	
     862:	95 98       	cbi	0x12, 5	; 18
	//_delay_us(2);
	
	GET_DATA(data);
     864:	84 e4       	ldi	r24, 0x44	; 68
     866:	69 e0       	ldi	r22, 0x09	; 9
     868:	ae 01       	movw	r20, r28
     86a:	4f 5f       	subi	r20, 0xFF	; 255
     86c:	5f 4f       	sbci	r21, 0xFF	; 255
     86e:	ec d4       	rcall	.+2520   	; 0x1248 <mcp23008_ReadReg>

	SetPin(CTRL_PORT,RD);
     870:	95 9a       	sbi	0x12, 5	; 18
	
	if(ReadRom == 0)
     872:	11 23       	and	r17, r17
     874:	09 f4       	brne	.+2      	; 0x878 <_ReadByte+0x34>
	{
		SetPin(CTRL_PORT,CS1);
     876:	97 9a       	sbi	0x12, 7	; 18
	}
	
	return data;
}
     878:	89 81       	ldd	r24, Y+1	; 0x01
     87a:	0f 90       	pop	r0
     87c:	cf 91       	pop	r28
     87e:	df 91       	pop	r29
     880:	1f 91       	pop	r17
     882:	08 95       	ret

00000884 <GetGBInfo>:
options : 
	0 : Get Full Header
	1 : Get Name,Rom/Ram Size, Cart Type
*/
int8_t GetGBInfo(char* GameName, uint8_t* romFlag , uint8_t* ramFlag)
{
     884:	6f 92       	push	r6
     886:	7f 92       	push	r7
     888:	8f 92       	push	r8
     88a:	9f 92       	push	r9
     88c:	af 92       	push	r10
     88e:	bf 92       	push	r11
     890:	cf 92       	push	r12
     892:	df 92       	push	r13
     894:	ff 92       	push	r15
     896:	0f 93       	push	r16
     898:	1f 93       	push	r17
     89a:	df 93       	push	r29
     89c:	cf 93       	push	r28
     89e:	cd b7       	in	r28, 0x3d	; 61
     8a0:	de b7       	in	r29, 0x3e	; 62
     8a2:	c1 58       	subi	r28, 0x81	; 129
     8a4:	d0 40       	sbci	r29, 0x00	; 0
     8a6:	0f b6       	in	r0, 0x3f	; 63
     8a8:	f8 94       	cli
     8aa:	de bf       	out	0x3e, r29	; 62
     8ac:	0f be       	out	0x3f, r0	; 63
     8ae:	cd bf       	out	0x3d, r28	; 61
     8b0:	6c 01       	movw	r12, r24
     8b2:	4b 01       	movw	r8, r22
     8b4:	3a 01       	movw	r6, r20
	if(GameName == NULL ||romFlag == NULL || ramFlag == NULL)
     8b6:	00 97       	sbiw	r24, 0x00	; 0
     8b8:	09 f4       	brne	.+2      	; 0x8bc <GetGBInfo+0x38>
     8ba:	72 c0       	rjmp	.+228    	; 0x9a0 <GetGBInfo+0x11c>
     8bc:	61 15       	cp	r22, r1
     8be:	71 05       	cpc	r23, r1
     8c0:	09 f4       	brne	.+2      	; 0x8c4 <GetGBInfo+0x40>
     8c2:	6e c0       	rjmp	.+220    	; 0x9a0 <GetGBInfo+0x11c>
     8c4:	41 15       	cp	r20, r1
     8c6:	51 05       	cpc	r21, r1
     8c8:	09 f4       	brne	.+2      	; 0x8cc <GetGBInfo+0x48>
     8ca:	6a c0       	rjmp	.+212    	; 0x9a0 <GetGBInfo+0x11c>
		return -1;
	
	GBC_Header temp;
	uint8_t header[0x51] = {0};
     8cc:	fe 01       	movw	r30, r28
     8ce:	f1 96       	adiw	r30, 0x31	; 49
     8d0:	81 e5       	ldi	r24, 0x51	; 81
     8d2:	df 01       	movw	r26, r30
     8d4:	1d 92       	st	X+, r1
     8d6:	8a 95       	dec	r24
     8d8:	e9 f7       	brne	.-6      	; 0x8d4 <GetGBInfo+0x50>
     8da:	5f 01       	movw	r10, r30
     8dc:	ff 24       	eor	r15, r15
     8de:	00 e0       	ldi	r16, 0x00	; 0
     8e0:	11 e0       	ldi	r17, 0x01	; 1
	//code that reads everything...
	
	//this saves alot of space, but at the cost of possible speed since we are forcing it to read everything
	for(uint8_t i = 0 ; i < ((sizeof(header) / sizeof(uint8_t))-1);i++)
	{
		header[i] = ReadByte(0x100+i);
     8e2:	81 e0       	ldi	r24, 0x01	; 1
     8e4:	b8 01       	movw	r22, r16
     8e6:	ae df       	rcall	.-164    	; 0x844 <_ReadByte>
		if(i >= 0 && i<=4 && header[i] == 0xFF)
     8e8:	05 30       	cpi	r16, 0x05	; 5
     8ea:	18 f4       	brcc	.+6      	; 0x8f2 <GetGBInfo+0x6e>
     8ec:	8f 3f       	cpi	r24, 0xFF	; 255
     8ee:	09 f4       	brne	.+2      	; 0x8f2 <GetGBInfo+0x6e>
		{
			FF_cnt++;
     8f0:	f3 94       	inc	r15
		}
		if(FF_cnt >= 3)
     8f2:	b2 e0       	ldi	r27, 0x02	; 2
     8f4:	bf 15       	cp	r27, r15
     8f6:	10 f4       	brcc	.+4      	; 0x8fc <GetGBInfo+0x78>
     8f8:	86 ef       	ldi	r24, 0xF6	; 246
     8fa:	53 c0       	rjmp	.+166    	; 0x9a2 <GetGBInfo+0x11e>
	//code that reads everything...
	
	//this saves alot of space, but at the cost of possible speed since we are forcing it to read everything
	for(uint8_t i = 0 ; i < ((sizeof(header) / sizeof(uint8_t))-1);i++)
	{
		header[i] = ReadByte(0x100+i);
     8fc:	f5 01       	movw	r30, r10
     8fe:	81 93       	st	Z+, r24
     900:	5f 01       	movw	r10, r30
     902:	0f 5f       	subi	r16, 0xFF	; 255
     904:	1f 4f       	sbci	r17, 0xFF	; 255
	uint8_t FF_cnt = 0;
	
	//code that reads everything...
	
	//this saves alot of space, but at the cost of possible speed since we are forcing it to read everything
	for(uint8_t i = 0 ; i < ((sizeof(header) / sizeof(uint8_t))-1);i++)
     906:	f1 e0       	ldi	r31, 0x01	; 1
     908:	00 35       	cpi	r16, 0x50	; 80
     90a:	1f 07       	cpc	r17, r31
     90c:	51 f7       	brne	.-44     	; 0x8e2 <GetGBInfo+0x5e>
	//read and compare the logo. this should give it a quick check if its ok or not
	uint8_t Logo[0x30] = {
		0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B, 0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D,
		0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E, 0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99,
		0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC, 0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E
	};
     90e:	de 01       	movw	r26, r28
     910:	11 96       	adiw	r26, 0x01	; 1
     912:	e7 e1       	ldi	r30, 0x17	; 23
     914:	f1 e0       	ldi	r31, 0x01	; 1
     916:	80 e3       	ldi	r24, 0x30	; 48
     918:	01 90       	ld	r0, Z+
     91a:	0d 92       	st	X+, r0
     91c:	81 50       	subi	r24, 0x01	; 1
     91e:	e1 f7       	brne	.-8      	; 0x918 <GetGBInfo+0x94>
     920:	fe 01       	movw	r30, r28
     922:	f5 96       	adiw	r30, 0x35	; 53
     924:	de 01       	movw	r26, r28
     926:	11 96       	adiw	r26, 0x01	; 1

	//compare!	
	for(int8_t i =0;i< 0x30;i++)
     928:	9e 01       	movw	r18, r28
     92a:	2b 59       	subi	r18, 0x9B	; 155
     92c:	3f 4f       	sbci	r19, 0xFF	; 255
	{
		if(header[_CALC_ADDR(_ADDR_LOGO+i)] == Logo[i])
     92e:	90 81       	ld	r25, Z
     930:	8c 91       	ld	r24, X
     932:	98 17       	cp	r25, r24
     934:	11 f0       	breq	.+4      	; 0x93a <GetGBInfo+0xb6>
			continue;
     936:	88 ef       	ldi	r24, 0xF8	; 248
     938:	34 c0       	rjmp	.+104    	; 0x9a2 <GetGBInfo+0x11e>
     93a:	31 96       	adiw	r30, 0x01	; 1
     93c:	11 96       	adiw	r26, 0x01	; 1
		0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E, 0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99,
		0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC, 0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E
	};

	//compare!	
	for(int8_t i =0;i< 0x30;i++)
     93e:	e2 17       	cp	r30, r18
     940:	f3 07       	cpc	r31, r19
     942:	a9 f7       	brne	.-22     	; 0x92e <GetGBInfo+0xaa>

	uint8_t NameSize = 16;
	
	temp.OldLicenseeCode = header[_CALC_ADDR(_ADDR_OLD_LICODE)];
	//if its 0x33, we have a cart from past the SGB/GBC era. uses different mapping
	if(temp.OldLicenseeCode == 0x33)
     944:	fe 01       	movw	r30, r28
     946:	e4 58       	subi	r30, 0x84	; 132
     948:	ff 4f       	sbci	r31, 0xFF	; 255
     94a:	80 81       	ld	r24, Z
     94c:	83 33       	cpi	r24, 0x33	; 51
     94e:	11 f0       	breq	.+4      	; 0x954 <GetGBInfo+0xd0>
     950:	40 e1       	ldi	r20, 0x10	; 16
     952:	01 c0       	rjmp	.+2      	; 0x956 <GetGBInfo+0xd2>
     954:	4b e0       	ldi	r20, 0x0B	; 11
		NameSize = 16;
		temp.GBCFlag = 0x00;
	}

	//memset(temp.Name,0,17);
	memset(GameName,0,17);
     956:	81 e1       	ldi	r24, 0x11	; 17
     958:	d6 01       	movw	r26, r12
     95a:	1d 92       	st	X+, r1
     95c:	8a 95       	dec	r24
     95e:	e9 f7       	brne	.-6      	; 0x95a <GetGBInfo+0xd6>
     960:	de 01       	movw	r26, r28
     962:	ab 59       	subi	r26, 0x9B	; 155
     964:	bf 4f       	sbci	r27, 0xFF	; 255
     966:	5c 2d       	mov	r21, r12
     968:	f6 01       	movw	r30, r12
	for(uint8_t i = 0;i < NameSize;i++)
	{
		//temp.Name[i] = header[_CALC_ADDR(_ADDR_NAME+i)];
		GameName[i] = header[_CALC_ADDR(_ADDR_NAME+i)];
     96a:	8d 91       	ld	r24, X+
     96c:	81 93       	st	Z+, r24
		temp.GBCFlag = 0x00;
	}

	//memset(temp.Name,0,17);
	memset(GameName,0,17);
	for(uint8_t i = 0;i < NameSize;i++)
     96e:	8e 2f       	mov	r24, r30
     970:	85 1b       	sub	r24, r21
     972:	84 17       	cp	r24, r20
     974:	d0 f3       	brcs	.-12     	; 0x96a <GetGBInfo+0xe6>
	{
		temp.GlobalChecksum[i] = header[_CALC_ADDR(_ADDR_GLBL_CHECKSUM+i)];
	}
	*/
	
	temp.CartType = header[_CALC_ADDR(_ADDR_CART_TYPE)];
     976:	fe 01       	movw	r30, r28
     978:	e8 58       	subi	r30, 0x88	; 136
     97a:	ff 4f       	sbci	r31, 0xFF	; 255
     97c:	80 81       	ld	r24, Z
	//temp.RomSizeFlag = header[_CALC_ADDR(_ADDR_ROM_SIZE)];
	*romFlag = header[_CALC_ADDR(_ADDR_ROM_SIZE)];
     97e:	fe 01       	movw	r30, r28
     980:	e7 58       	subi	r30, 0x87	; 135
     982:	ff 4f       	sbci	r31, 0xFF	; 255
     984:	90 81       	ld	r25, Z
     986:	f4 01       	movw	r30, r8
     988:	90 83       	st	Z, r25
	//temp.RamSize = header[_CALC_ADDR(_ADDR_RAM_SIZE)];	
	*ramFlag = header[_CALC_ADDR(_ADDR_RAM_SIZE)];
     98a:	fe 01       	movw	r30, r28
     98c:	e6 58       	subi	r30, 0x86	; 134
     98e:	ff 4f       	sbci	r31, 0xFF	; 255
     990:	90 81       	ld	r25, Z
     992:	d3 01       	movw	r26, r6
     994:	9c 93       	st	X, r25
	//temp.MBCType = GetMBCType(temp.CartType);
	LoadedBankType = GetMBCType(temp.CartType);
     996:	7f de       	rcall	.-770    	; 0x696 <GetMBCType>
     998:	80 93 65 01 	sts	0x0165, r24
     99c:	81 e0       	ldi	r24, 0x01	; 1
     99e:	01 c0       	rjmp	.+2      	; 0x9a2 <GetGBInfo+0x11e>
	
	return 1;	
     9a0:	8f ef       	ldi	r24, 0xFF	; 255
}
     9a2:	cf 57       	subi	r28, 0x7F	; 127
     9a4:	df 4f       	sbci	r29, 0xFF	; 255
     9a6:	0f b6       	in	r0, 0x3f	; 63
     9a8:	f8 94       	cli
     9aa:	de bf       	out	0x3e, r29	; 62
     9ac:	0f be       	out	0x3f, r0	; 63
     9ae:	cd bf       	out	0x3d, r28	; 61
     9b0:	cf 91       	pop	r28
     9b2:	df 91       	pop	r29
     9b4:	1f 91       	pop	r17
     9b6:	0f 91       	pop	r16
     9b8:	ff 90       	pop	r15
     9ba:	df 90       	pop	r13
     9bc:	cf 90       	pop	r12
     9be:	bf 90       	pop	r11
     9c0:	af 90       	pop	r10
     9c2:	9f 90       	pop	r9
     9c4:	8f 90       	pop	r8
     9c6:	7f 90       	pop	r7
     9c8:	6f 90       	pop	r6
     9ca:	08 95       	ret

000009cc <OpenRam>:
	_WriteByte(0,addr,byte);
	return 1;
}
int8_t OpenRam(void)
{
	if(LoadedBankType == MBC_NONE || LoadedBankType == MBC_UNSUPPORTED)
     9cc:	80 91 65 01 	lds	r24, 0x0165
     9d0:	89 30       	cpi	r24, 0x09	; 9
     9d2:	d9 f0       	breq	.+54     	; 0xa0a <OpenRam+0x3e>
     9d4:	88 23       	and	r24, r24
     9d6:	c9 f0       	breq	.+50     	; 0xa0a <OpenRam+0x3e>
		return ERR_NO_MBC;
	
	SetPin(CTRL_PORT,WD);
     9d8:	96 9a       	sbi	0x12, 6	; 18
	SetPin(CTRL_PORT,RD);
     9da:	95 9a       	sbi	0x12, 5	; 18
	SetPin(CTRL_PORT,CS1);	
     9dc:	97 9a       	sbi	0x12, 7	; 18
	
	if(LoadedBankType == MBC2)
     9de:	80 32       	cpi	r24, 0x20	; 32
     9e0:	21 f4       	brne	.+8      	; 0x9ea <OpenRam+0x1e>
	{
		//the ghost read fix from https://www.insidegadgets.com/2011/03/28/gbcartread-arduino-based-gameboy-cart-reader-%E2%80%93-part-2-read-the-ram/
		//he said it otherwise had issues with MBC2 :/
		ReadByte(0x0134);
     9e2:	81 e0       	ldi	r24, 0x01	; 1
     9e4:	64 e3       	ldi	r22, 0x34	; 52
     9e6:	71 e0       	ldi	r23, 0x01	; 1
     9e8:	2d df       	rcall	.-422    	; 0x844 <_ReadByte>
	}
		
	//set banking mode to RAM
	if(LoadedBankType == MBC1)
     9ea:	80 91 65 01 	lds	r24, 0x0165
     9ee:	80 31       	cpi	r24, 0x10	; 16
     9f0:	29 f4       	brne	.+10     	; 0x9fc <OpenRam+0x30>
		WriteByte(0x6000,0x01);
     9f2:	81 e0       	ldi	r24, 0x01	; 1
     9f4:	60 e0       	ldi	r22, 0x00	; 0
     9f6:	70 e6       	ldi	r23, 0x60	; 96
     9f8:	41 e0       	ldi	r20, 0x01	; 1
     9fa:	9b de       	rcall	.-714    	; 0x732 <_WriteByte>
	
	//Init the MBC Ram!
	//uint16_t init_addr = 0x0000; 
	WriteByte(0x0000,0x0A);
     9fc:	81 e0       	ldi	r24, 0x01	; 1
     9fe:	60 e0       	ldi	r22, 0x00	; 0
     a00:	70 e0       	ldi	r23, 0x00	; 0
     a02:	4a e0       	ldi	r20, 0x0A	; 10
     a04:	96 de       	rcall	.-724    	; 0x732 <_WriteByte>
     a06:	81 e0       	ldi	r24, 0x01	; 1
     a08:	08 95       	ret
	
	return 1;
     a0a:	8c ee       	ldi	r24, 0xEC	; 236
}
     a0c:	08 95       	ret

00000a0e <ReadRAMByte>:
	}
	
	return data;
}
uint8_t ReadRAMByte(uint16_t address)
{
     a0e:	bc 01       	movw	r22, r24
	if(LoadedBankType == MBC_NONE || LoadedBankType == MBC_UNSUPPORTED)
     a10:	80 91 65 01 	lds	r24, 0x0165
     a14:	89 30       	cpi	r24, 0x09	; 9
     a16:	59 f0       	breq	.+22     	; 0xa2e <ReadRAMByte+0x20>
     a18:	88 23       	and	r24, r24
     a1a:	49 f0       	breq	.+18     	; 0xa2e <ReadRAMByte+0x20>
		return ERR_NO_MBC;
	
	uint8_t ret = _ReadByte(0,address);
     a1c:	80 e0       	ldi	r24, 0x00	; 0
     a1e:	12 df       	rcall	.-476    	; 0x844 <_ReadByte>
     a20:	98 2f       	mov	r25, r24
	
	if(LoadedBankType == MBC2)
     a22:	80 91 65 01 	lds	r24, 0x0165
     a26:	80 32       	cpi	r24, 0x20	; 32
     a28:	19 f4       	brne	.+6      	; 0xa30 <ReadRAMByte+0x22>
	{
		//MBC2 only has the lower 4 bits as data, so we return it as 0xFx
		return (0xF0 | ret );
     a2a:	90 6f       	ori	r25, 0xF0	; 240
     a2c:	01 c0       	rjmp	.+2      	; 0xa30 <ReadRAMByte+0x22>
     a2e:	9c ee       	ldi	r25, 0xEC	; 236
	else
	{
		return ret;
	}
	
}
     a30:	89 2f       	mov	r24, r25
     a32:	08 95       	ret

00000a34 <Setup_GB_Pins>:
}
void Setup_GB_Pins(void)
{
#ifdef GPIO_EXTENDER_MODE
	//setup the mcp23008, as its the source of everything xD
	mcp23008_init(ADDR_CHIP_1);
     a34:	80 e4       	ldi	r24, 0x40	; 64
     a36:	25 d4       	rcall	.+2122   	; 0x1282 <mcp23008_init>
	mcp23008_init(ADDR_CHIP_2);
     a38:	82 e4       	ldi	r24, 0x42	; 66
     a3a:	23 d4       	rcall	.+2118   	; 0x1282 <mcp23008_init>
	mcp23008_init(DATA_CHIP_1);
     a3c:	84 e4       	ldi	r24, 0x44	; 68
     a3e:	21 d4       	rcall	.+2114   	; 0x1282 <mcp23008_init>

	mcp23008_WriteReg(ADDR_CHIP_1,IODIR,0x00);
     a40:	80 e4       	ldi	r24, 0x40	; 64
     a42:	60 e0       	ldi	r22, 0x00	; 0
     a44:	40 e0       	ldi	r20, 0x00	; 0
     a46:	ec d3       	rcall	.+2008   	; 0x1220 <mcp23008_WriteReg>
	mcp23008_WriteReg(ADDR_CHIP_2,IODIR,0x00);	
     a48:	82 e4       	ldi	r24, 0x42	; 66
     a4a:	60 e0       	ldi	r22, 0x00	; 0
     a4c:	40 e0       	ldi	r20, 0x00	; 0
     a4e:	e8 d3       	rcall	.+2000   	; 0x1220 <mcp23008_WriteReg>
	ADDR_DDR2 = 0xFF;	
	
#endif	

	//setup data pins as input
	SetDataPinsAsInput(); 
     a50:	67 de       	rcall	.-818    	; 0x720 <SetDataPinsAsInput>
	
	//setup D pins as well for the other, as output
	CTRL_DDR |= ( (0 << BTN) | (1 << RD) | (1 << WD) | (1 << CS1) | (1 << CS2) );//0b01111100;
     a52:	81 b3       	in	r24, 0x11	; 17
     a54:	88 6e       	ori	r24, 0xE8	; 232
     a56:	81 bb       	out	0x11, r24	; 17
	//FUCK TRISTATE BULLSHIT xD set the mode of the pins correctly!
	CTRL_PORT |= ((1 << BTN) | (1 << RD) | (1 << WD) | (1 << CS1) | (1 << CS2) ); //0b01111100;
     a58:	82 b3       	in	r24, 0x12	; 18
     a5a:	88 6f       	ori	r24, 0xF8	; 248
     a5c:	82 bb       	out	0x12, r24	; 18
	
	SetPin(CTRL_PORT,WD);
     a5e:	96 9a       	sbi	0x12, 6	; 18
	SetPin(CTRL_PORT,RD);
     a60:	95 9a       	sbi	0x12, 5	; 18
	SetPin(CTRL_PORT,CS1);
     a62:	97 9a       	sbi	0x12, 7	; 18
	SetPin(CTRL_PORT,CS2);
     a64:	93 9a       	sbi	0x12, 3	; 18
}
     a66:	08 95       	ret

00000a68 <API_ResetGameInfo>:
void API_ResetGameInfo(void)
{
	//reset GameInfo
	//code only checks byte 0 of the name. invalidate that and its ok :P
	//this produces smaller code too xD
	gameInfo.Name[0] = 0xFF;
     a68:	8f ef       	ldi	r24, 0xFF	; 255
     a6a:	80 93 87 01 	sts	0x0187, r24
}
     a6e:	08 95       	ret

00000a70 <API_CartInserted>:
	
	API_ResetGameInfo();
	return ret;
}
int8_t API_CartInserted(void)
{
     a70:	90 e0       	ldi	r25, 0x00	; 0
     a72:	80 91 87 01 	lds	r24, 0x0187
     a76:	8f 3f       	cpi	r24, 0xFF	; 255
     a78:	09 f0       	breq	.+2      	; 0xa7c <API_CartInserted+0xc>
     a7a:	91 e0       	ldi	r25, 0x01	; 1
	return (gameInfo.Name[0] == 0xFF)?0:1;
}
     a7c:	89 2f       	mov	r24, r25
     a7e:	08 95       	ret

00000a80 <API_Send_Cart_Type>:
	cprintf_char(API_FILESIZE_END);
	return;
}

void API_Send_Cart_Type(void)
{
     a80:	1f 93       	push	r17
	uint8_t toSend = 0xFF;
	
	if(_gba_cart)
     a82:	80 91 47 01 	lds	r24, 0x0147
     a86:	88 23       	and	r24, r24
     a88:	11 f0       	breq	.+4      	; 0xa8e <API_Send_Cart_Type+0xe>
     a8a:	1b e7       	ldi	r17, 0x7B	; 123
     a8c:	10 c0       	rjmp	.+32     	; 0xaae <API_Send_Cart_Type+0x2e>
		toSend = API_GBA_ONLY;
	else
	{	
		switch(gameInfo.flag)
     a8e:	80 91 9f 01 	lds	r24, 0x019F
     a92:	80 38       	cpi	r24, 0x80	; 128
     a94:	29 f0       	breq	.+10     	; 0xaa0 <API_Send_Cart_Type+0x20>
     a96:	80 3c       	cpi	r24, 0xC0	; 192
     a98:	39 f0       	breq	.+14     	; 0xaa8 <API_Send_Cart_Type+0x28>
     a9a:	88 23       	and	r24, r24
     a9c:	39 f0       	breq	.+14     	; 0xaac <API_Send_Cart_Type+0x2c>
     a9e:	02 c0       	rjmp	.+4      	; 0xaa4 <API_Send_Cart_Type+0x24>
     aa0:	19 e7       	ldi	r17, 0x79	; 121
     aa2:	05 c0       	rjmp	.+10     	; 0xaae <API_Send_Cart_Type+0x2e>
     aa4:	1f ef       	ldi	r17, 0xFF	; 255
     aa6:	03 c0       	rjmp	.+6      	; 0xaae <API_Send_Cart_Type+0x2e>
     aa8:	18 e7       	ldi	r17, 0x78	; 120
     aaa:	01 c0       	rjmp	.+2      	; 0xaae <API_Send_Cart_Type+0x2e>
			case 0x80:
				toSend = API_GBC_HYBRID;
				break;
			case 0xC0:
				toSend = API_GBC_ONLY;
				break;
     aac:	1a e7       	ldi	r17, 0x7A	; 122
				toSend = API_GBC_GB;
				break;
		}
	}
	
	cprintf_char(API_GB_CART_TYPE_START);
     aae:	86 e7       	ldi	r24, 0x76	; 118
     ab0:	a5 d2       	rcall	.+1354   	; 0xffc <cprintf_char>
	cprintf_char(toSend);
     ab2:	81 2f       	mov	r24, r17
     ab4:	a3 d2       	rcall	.+1350   	; 0xffc <cprintf_char>
	cprintf_char(API_GB_CART_TYPE_END);
     ab6:	87 e7       	ldi	r24, 0x77	; 119
     ab8:	a1 d2       	rcall	.+1346   	; 0xffc <cprintf_char>
     aba:	1f 91       	pop	r17
     abc:	08 95       	ret

00000abe <API_Send_Size>:
	return;
}

void API_Send_Size(void)
{
	cprintf_char(API_FILESIZE_START);
     abe:	86 e9       	ldi	r24, 0x96	; 150
     ac0:	9d d2       	rcall	.+1338   	; 0xffc <cprintf_char>
	cprintf_char((gameInfo.fileSize >> 24) & 0xFF);
     ac2:	80 91 9e 01 	lds	r24, 0x019E
     ac6:	9a d2       	rcall	.+1332   	; 0xffc <cprintf_char>
	cprintf_char((gameInfo.fileSize >> 16) & 0xFF);
     ac8:	80 91 9d 01 	lds	r24, 0x019D
     acc:	97 d2       	rcall	.+1326   	; 0xffc <cprintf_char>
	cprintf_char((gameInfo.fileSize >> 8) & 0xFF);
     ace:	80 91 9b 01 	lds	r24, 0x019B
     ad2:	90 91 9c 01 	lds	r25, 0x019C
     ad6:	a0 91 9d 01 	lds	r26, 0x019D
     ada:	b0 91 9e 01 	lds	r27, 0x019E
     ade:	89 2f       	mov	r24, r25
     ae0:	9a 2f       	mov	r25, r26
     ae2:	ab 2f       	mov	r26, r27
     ae4:	bb 27       	eor	r27, r27
     ae6:	8a d2       	rcall	.+1300   	; 0xffc <cprintf_char>
	cprintf_char(gameInfo.fileSize & 0xFF);
     ae8:	80 91 9b 01 	lds	r24, 0x019B
     aec:	87 d2       	rcall	.+1294   	; 0xffc <cprintf_char>
	cprintf_char(API_FILESIZE_END);
     aee:	87 e9       	ldi	r24, 0x97	; 151
     af0:	85 d2       	rcall	.+1290   	; 0xffc <cprintf_char>
	return;
}
     af2:	08 95       	ret

00000af4 <API_Send_Abort>:
	SetPin(CTRL_PORT,CS2);
	API_ResetGameInfo();
	return 1;
}
void API_Send_Abort(uint8_t type)
{
     af4:	1f 93       	push	r17
     af6:	18 2f       	mov	r17, r24
	cprintf_char(API_ABORT);
     af8:	80 ef       	ldi	r24, 0xF0	; 240
     afa:	80 d2       	rcall	.+1280   	; 0xffc <cprintf_char>
	cprintf_char(type);
     afc:	81 2f       	mov	r24, r17
     afe:	7e d2       	rcall	.+1276   	; 0xffc <cprintf_char>
void API_ResetGameInfo(void)
{
	//reset GameInfo
	//code only checks byte 0 of the name. invalidate that and its ok :P
	//this produces smaller code too xD
	gameInfo.Name[0] = 0xFF;
     b00:	8f ef       	ldi	r24, 0xFF	; 255
     b02:	80 93 87 01 	sts	0x0187, r24
void API_Send_Abort(uint8_t type)
{
	cprintf_char(API_ABORT);
	cprintf_char(type);
	API_ResetGameInfo();
}
     b06:	1f 91       	pop	r17
     b08:	08 95       	ret

00000b0a <API_Send_Name>:

void API_Send_Name(void)
{
     b0a:	0f 93       	push	r16
     b0c:	1f 93       	push	r17
	cprintf_char(API_GAMENAME_START);
     b0e:	86 e8       	ldi	r24, 0x86	; 134
     b10:	75 d2       	rcall	.+1258   	; 0xffc <cprintf_char>
	cprintf_char(strnlen(gameInfo.Name,17));
     b12:	07 e8       	ldi	r16, 0x87	; 135
     b14:	11 e0       	ldi	r17, 0x01	; 1
     b16:	c8 01       	movw	r24, r16
     b18:	61 e1       	ldi	r22, 0x11	; 17
     b1a:	70 e0       	ldi	r23, 0x00	; 0
     b1c:	ef d3       	rcall	.+2014   	; 0x12fc <strnlen>
     b1e:	6e d2       	rcall	.+1244   	; 0xffc <cprintf_char>
	cprintf_char(API_GAMENAME_END);
     b20:	87 e8       	ldi	r24, 0x87	; 135
     b22:	6c d2       	rcall	.+1240   	; 0xffc <cprintf_char>
	cprintf(gameInfo.Name);
     b24:	c8 01       	movw	r24, r16
     b26:	73 d2       	rcall	.+1254   	; 0x100e <cprintf_string>
	return;
}
     b28:	1f 91       	pop	r17
     b2a:	0f 91       	pop	r16
     b2c:	08 95       	ret

00000b2e <API_GetGameInfo>:
	//this produces smaller code too xD
	gameInfo.Name[0] = 0xFF;
}
int8_t API_GetGameInfo(void)
{
	if(gameInfo.Name[0] != 0xFF)
     b2e:	80 91 87 01 	lds	r24, 0x0187
     b32:	8f 3f       	cpi	r24, 0xFF	; 255
     b34:	e1 f4       	brne	.+56     	; 0xb6e <API_GetGameInfo+0x40>
		return 1;
	int8_t ret = 0;
	
	if(_gba_cart)
     b36:	80 91 47 01 	lds	r24, 0x0147
     b3a:	88 23       	and	r24, r24
     b3c:	21 f0       	breq	.+8      	; 0xb46 <API_GetGameInfo+0x18>
	{
		ret = GetGBAInfo(gameInfo.Name);
     b3e:	87 e8       	ldi	r24, 0x87	; 135
     b40:	91 e0       	ldi	r25, 0x01	; 1
     b42:	d0 db       	rcall	.-2144   	; 0x2e4 <GetGBAInfo>
     b44:	09 c0       	rjmp	.+18     	; 0xb58 <API_GetGameInfo+0x2a>
	}
	else
	{
		ClearPin(CTRL_PORT,CS2);
     b46:	93 98       	cbi	0x12, 3	; 18
		SetPin(CTRL_PORT,CS2);
     b48:	93 9a       	sbi	0x12, 3	; 18
		ret = GetGBInfo(gameInfo.Name,&gameInfo.RomSizeFlag,&gameInfo.RamSize);
     b4a:	87 e8       	ldi	r24, 0x87	; 135
     b4c:	91 e0       	ldi	r25, 0x01	; 1
     b4e:	69 e9       	ldi	r22, 0x99	; 153
     b50:	71 e0       	ldi	r23, 0x01	; 1
     b52:	4a e9       	ldi	r20, 0x9A	; 154
     b54:	51 e0       	ldi	r21, 0x01	; 1
     b56:	96 de       	rcall	.-724    	; 0x884 <GetGBInfo>
     b58:	98 2f       	mov	r25, r24
	}
	
	if(ret > 0 && gameInfo.Name[0] != 0xFF)
     b5a:	18 16       	cp	r1, r24
     b5c:	24 f4       	brge	.+8      	; 0xb66 <API_GetGameInfo+0x38>
     b5e:	80 91 87 01 	lds	r24, 0x0187
     b62:	8f 3f       	cpi	r24, 0xFF	; 255
     b64:	21 f4       	brne	.+8      	; 0xb6e <API_GetGameInfo+0x40>
void API_ResetGameInfo(void)
{
	//reset GameInfo
	//code only checks byte 0 of the name. invalidate that and its ok :P
	//this produces smaller code too xD
	gameInfo.Name[0] = 0xFF;
     b66:	8f ef       	ldi	r24, 0xFF	; 255
     b68:	80 93 87 01 	sts	0x0187, r24
     b6c:	01 c0       	rjmp	.+2      	; 0xb70 <API_GetGameInfo+0x42>
	
	if(ret > 0 && gameInfo.Name[0] != 0xFF)
		return 1;
	
	API_ResetGameInfo();
	return ret;
     b6e:	91 e0       	ldi	r25, 0x01	; 1
}
     b70:	89 2f       	mov	r24, r25
     b72:	08 95       	ret

00000b74 <API_GetRam>:
	
	API_ResetGameInfo();
	return 1;
}
int8_t API_GetRam(void)
{
     b74:	ff 92       	push	r15
     b76:	0f 93       	push	r16
     b78:	1f 93       	push	r17
     b7a:	df 93       	push	r29
     b7c:	cf 93       	push	r28
     b7e:	00 d0       	rcall	.+0      	; 0xb80 <API_GetRam+0xc>
     b80:	0f 92       	push	r0
     b82:	cd b7       	in	r28, 0x3d	; 61
     b84:	de b7       	in	r29, 0x3e	; 62
	//reset game cart. this causes all banks & states to reset
	ClearPin(CTRL_PORT,CS2);
     b86:	93 98       	cbi	0x12, 3	; 18
	
	SetPin(CTRL_PORT,WD);
     b88:	96 9a       	sbi	0x12, 6	; 18
	SetPin(CTRL_PORT,RD);
     b8a:	95 9a       	sbi	0x12, 5	; 18
	SetPin(CTRL_PORT,CS1);
     b8c:	97 9a       	sbi	0x12, 7	; 18
	SetPin(CTRL_PORT,CS2);
     b8e:	93 9a       	sbi	0x12, 3	; 18
	
	if(!API_GetGameInfo())
     b90:	ce df       	rcall	.-100    	; 0xb2e <API_GetGameInfo>
     b92:	88 23       	and	r24, r24
     b94:	21 f4       	brne	.+8      	; 0xb9e <API_GetRam+0x2a>
	{
		API_Send_Abort(API_ABORT_CMD);
     b96:	82 ef       	ldi	r24, 0xF2	; 242
     b98:	ad df       	rcall	.-166    	; 0xaf4 <API_Send_Abort>
     b9a:	87 ef       	ldi	r24, 0xF7	; 247
     b9c:	3b c0       	rjmp	.+118    	; 0xc14 <API_GetRam+0xa0>
		return ERR_NO_INFO;
	}
	
	if(LoadedBankType == MBC_NONE || LoadedBankType == MBC_UNSUPPORTED)
     b9e:	80 91 65 01 	lds	r24, 0x0165
     ba2:	89 30       	cpi	r24, 0x09	; 9
     ba4:	b1 f1       	breq	.+108    	; 0xc12 <API_GetRam+0x9e>
     ba6:	88 23       	and	r24, r24
     ba8:	a1 f1       	breq	.+104    	; 0xc12 <API_GetRam+0x9e>
		return ERR_NO_MBC;
	
	//read RAM Address'
	uint16_t addr = 0xA000;
	uint16_t end_addr = 0xC000; //actually ends at 0xBFFF
     baa:	80 e0       	ldi	r24, 0x00	; 0
     bac:	90 ec       	ldi	r25, 0xC0	; 192
     bae:	9b 83       	std	Y+3, r25	; 0x03
     bb0:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t banks = 0;
     bb2:	19 82       	std	Y+1, r1	; 0x01
	
	int8_t ret = GetRamDetails(&end_addr,&banks,gameInfo.RamSize);
     bb4:	ce 01       	movw	r24, r28
     bb6:	02 96       	adiw	r24, 0x02	; 2
     bb8:	be 01       	movw	r22, r28
     bba:	6f 5f       	subi	r22, 0xFF	; 255
     bbc:	7f 4f       	sbci	r23, 0xFF	; 255
     bbe:	40 91 9a 01 	lds	r20, 0x019A
     bc2:	2f dd       	rcall	.-1442   	; 0x622 <GetRamDetails>
	
	if(ret < 0)
     bc4:	87 ff       	sbrs	r24, 7
     bc6:	02 c0       	rjmp	.+4      	; 0xbcc <API_GetRam+0x58>
     bc8:	83 ee       	ldi	r24, 0xE3	; 227
     bca:	24 c0       	rjmp	.+72     	; 0xc14 <API_GetRam+0xa0>
		return ERR_NO_SAVE;
	
	OpenRam();
     bcc:	ff de       	rcall	.-514    	; 0x9cc <OpenRam>
     bce:	ff 24       	eor	r15, r15
     bd0:	15 c0       	rjmp	.+42     	; 0xbfc <API_GetRam+0x88>
	//_delay_us(5);

	for(uint8_t bank = 0;bank < banks;bank++)
	{
		//if we aren't dealing with MBC2, set bank to 0!
		if(LoadedBankType != MBC2)
     bd2:	80 91 65 01 	lds	r24, 0x0165
     bd6:	80 32       	cpi	r24, 0x20	; 32
     bd8:	11 f0       	breq	.+4      	; 0xbde <API_GetRam+0x6a>
			SwitchRAMBank(bank);	
     bda:	8f 2d       	mov	r24, r15
     bdc:	cc dd       	rcall	.-1128   	; 0x776 <SwitchRAMBank>
     bde:	00 e0       	ldi	r16, 0x00	; 0
     be0:	10 ea       	ldi	r17, 0xA0	; 160
     be2:	06 c0       	rjmp	.+12     	; 0xbf0 <API_GetRam+0x7c>
		
		for(uint16_t i = addr;i< end_addr ;i++)
		{
			cprintf_char(ReadRAMByte(i));
     be4:	c8 01       	movw	r24, r16
     be6:	13 df       	rcall	.-474    	; 0xa0e <ReadRAMByte>
     be8:	09 d2       	rcall	.+1042   	; 0xffc <cprintf_char>
			//_delay_us(5);
			//asm ("nop");
			asm ("nop");	
     bea:	00 00       	nop
	{
		//if we aren't dealing with MBC2, set bank to 0!
		if(LoadedBankType != MBC2)
			SwitchRAMBank(bank);	
		
		for(uint16_t i = addr;i< end_addr ;i++)
     bec:	0f 5f       	subi	r16, 0xFF	; 255
     bee:	1f 4f       	sbci	r17, 0xFF	; 255
     bf0:	8a 81       	ldd	r24, Y+2	; 0x02
     bf2:	9b 81       	ldd	r25, Y+3	; 0x03
     bf4:	08 17       	cp	r16, r24
     bf6:	19 07       	cpc	r17, r25
     bf8:	a8 f3       	brcs	.-22     	; 0xbe4 <API_GetRam+0x70>
		return ERR_NO_SAVE;
	
	OpenRam();
	//_delay_us(5);

	for(uint8_t bank = 0;bank < banks;bank++)
     bfa:	f3 94       	inc	r15
     bfc:	89 81       	ldd	r24, Y+1	; 0x01
     bfe:	f8 16       	cp	r15, r24
     c00:	40 f3       	brcs	.-48     	; 0xbd2 <API_GetRam+0x5e>
			//asm ("nop");
			asm ("nop");	
		}
	}
	
	CloseRam();	
     c02:	02 de       	rcall	.-1020   	; 0x808 <CloseRam>
	ClearPin(CTRL_PORT,CS2);
     c04:	93 98       	cbi	0x12, 3	; 18
	SetPin(CTRL_PORT,CS2);
     c06:	93 9a       	sbi	0x12, 3	; 18
void API_ResetGameInfo(void)
{
	//reset GameInfo
	//code only checks byte 0 of the name. invalidate that and its ok :P
	//this produces smaller code too xD
	gameInfo.Name[0] = 0xFF;
     c08:	8f ef       	ldi	r24, 0xFF	; 255
     c0a:	80 93 87 01 	sts	0x0187, r24
     c0e:	81 e0       	ldi	r24, 0x01	; 1
     c10:	01 c0       	rjmp	.+2      	; 0xc14 <API_GetRam+0xa0>
	
	CloseRam();	
	ClearPin(CTRL_PORT,CS2);
	SetPin(CTRL_PORT,CS2);
	API_ResetGameInfo();
	return 1;
     c12:	8c ee       	ldi	r24, 0xEC	; 236
}
     c14:	0f 90       	pop	r0
     c16:	0f 90       	pop	r0
     c18:	0f 90       	pop	r0
     c1a:	cf 91       	pop	r28
     c1c:	df 91       	pop	r29
     c1e:	1f 91       	pop	r17
     c20:	0f 91       	pop	r16
     c22:	ff 90       	pop	r15
     c24:	08 95       	ret

00000c26 <API_GetRom>:
	{
		return API_WriteGBRam();
	}
}
int8_t API_GetRom(void)
{
     c26:	8f 92       	push	r8
     c28:	9f 92       	push	r9
     c2a:	af 92       	push	r10
     c2c:	bf 92       	push	r11
     c2e:	cf 92       	push	r12
     c30:	df 92       	push	r13
     c32:	ef 92       	push	r14
     c34:	ff 92       	push	r15
     c36:	0f 93       	push	r16
     c38:	1f 93       	push	r17
     c3a:	cf 93       	push	r28
     c3c:	df 93       	push	r29
	SetPin(CTRL_PORT,WD);
     c3e:	96 9a       	sbi	0x12, 6	; 18
	SetPin(CTRL_PORT,RD);
     c40:	95 9a       	sbi	0x12, 5	; 18
	SetPin(CTRL_PORT,CS1);
     c42:	97 9a       	sbi	0x12, 7	; 18
	SetPin(CTRL_PORT,CS2);
     c44:	93 9a       	sbi	0x12, 3	; 18
	
	uint32_t _readSize = gameInfo.fileSize / 2;
     c46:	80 90 9b 01 	lds	r8, 0x019B
     c4a:	90 90 9c 01 	lds	r9, 0x019C
     c4e:	a0 90 9d 01 	lds	r10, 0x019D
     c52:	b0 90 9e 01 	lds	r11, 0x019E
     c56:	b6 94       	lsr	r11
     c58:	a7 94       	ror	r10
     c5a:	97 94       	ror	r9
     c5c:	87 94       	ror	r8
	if(_gba_cart)
     c5e:	80 91 47 01 	lds	r24, 0x0147
     c62:	88 23       	and	r24, r24
     c64:	51 f1       	breq	.+84     	; 0xcba <API_GetRom+0x94>
	{			
		//for dumping we use the GBA's increment reading mode. this saves a alot of cycles and is therefor a lot faster
		//see the function for more info.
		uint16_t data = ReadGBAIncrementedBytes(1,0);
     c66:	81 e0       	ldi	r24, 0x01	; 1
     c68:	40 e0       	ldi	r20, 0x00	; 0
     c6a:	50 e0       	ldi	r21, 0x00	; 0
     c6c:	60 e0       	ldi	r22, 0x00	; 0
     c6e:	70 e0       	ldi	r23, 0x00	; 0
     c70:	4b dc       	rcall	.-1898   	; 0x508 <_ReadGBAIncrementedBytes>
     c72:	19 2f       	mov	r17, r25
		cprintf_char((uint8_t)data & 0xFF);
     c74:	c3 d1       	rcall	.+902    	; 0xffc <cprintf_char>
		asm("nop");
     c76:	00 00       	nop
		cprintf_char((data >> 8) & 0xFF);
     c78:	81 2f       	mov	r24, r17
     c7a:	c0 d1       	rcall	.+896    	; 0xffc <cprintf_char>
     c7c:	31 e0       	ldi	r19, 0x01	; 1
     c7e:	c3 2e       	mov	r12, r19
     c80:	d1 2c       	mov	r13, r1
     c82:	e1 2c       	mov	r14, r1
     c84:	f1 2c       	mov	r15, r1
     c86:	12 c0       	rjmp	.+36     	; 0xcac <API_GetRom+0x86>
		
		for(uint32_t i = 1; i < _readSize;i++)
		{
			//GBA rom's seem to loop every 0x10000 (0x20000 in file). therefor we explicitly set the address every 0x10000 
			uint16_t data = ReadGBAIncrementedBytes((i%0x10000) == 0?1:0,i);
     c88:	80 e0       	ldi	r24, 0x00	; 0
     c8a:	c1 14       	cp	r12, r1
     c8c:	d1 04       	cpc	r13, r1
     c8e:	09 f4       	brne	.+2      	; 0xc92 <API_GetRom+0x6c>
     c90:	81 e0       	ldi	r24, 0x01	; 1
     c92:	b7 01       	movw	r22, r14
     c94:	a6 01       	movw	r20, r12
     c96:	38 dc       	rcall	.-1936   	; 0x508 <_ReadGBAIncrementedBytes>
     c98:	19 2f       	mov	r17, r25
			cprintf_char((uint8_t)data & 0xFF);
     c9a:	b0 d1       	rcall	.+864    	; 0xffc <cprintf_char>
			asm("nop");
     c9c:	00 00       	nop
			cprintf_char((data >> 8) & 0xFF);
     c9e:	81 2f       	mov	r24, r17
     ca0:	ad d1       	rcall	.+858    	; 0xffc <cprintf_char>
		uint16_t data = ReadGBAIncrementedBytes(1,0);
		cprintf_char((uint8_t)data & 0xFF);
		asm("nop");
		cprintf_char((data >> 8) & 0xFF);
		
		for(uint32_t i = 1; i < _readSize;i++)
     ca2:	08 94       	sec
     ca4:	c1 1c       	adc	r12, r1
     ca6:	d1 1c       	adc	r13, r1
     ca8:	e1 1c       	adc	r14, r1
     caa:	f1 1c       	adc	r15, r1
     cac:	c8 14       	cp	r12, r8
     cae:	d9 04       	cpc	r13, r9
     cb0:	ea 04       	cpc	r14, r10
     cb2:	fb 04       	cpc	r15, r11
     cb4:	48 f3       	brcs	.-46     	; 0xc88 <API_GetRom+0x62>
			uint16_t data = ReadGBAIncrementedBytes((i%0x10000) == 0?1:0,i);
			cprintf_char((uint8_t)data & 0xFF);
			asm("nop");
			cprintf_char((data >> 8) & 0xFF);
		}
		SetPin(CTRL_PORT,CS1);
     cb6:	97 9a       	sbi	0x12, 7	; 18
     cb8:	23 c0       	rjmp	.+70     	; 0xd00 <API_GetRom+0xda>
	}
	else
	{
		//reset cart
		ClearPin(CTRL_PORT,CS2);
     cba:	93 98       	cbi	0x12, 3	; 18
		SetPin(CTRL_PORT,CS2);
     cbc:	93 9a       	sbi	0x12, 3	; 18
		
		if(!API_GetGameInfo())
     cbe:	37 df       	rcall	.-402    	; 0xb2e <API_GetGameInfo>
     cc0:	88 23       	and	r24, r24
     cc2:	21 f4       	brne	.+8      	; 0xccc <API_GetRom+0xa6>
		{
			API_Send_Abort(API_ABORT_CMD);
     cc4:	82 ef       	ldi	r24, 0xF2	; 242
     cc6:	16 df       	rcall	.-468    	; 0xaf4 <API_Send_Abort>
     cc8:	87 ef       	ldi	r24, 0xF7	; 247
     cca:	1e c0       	rjmp	.+60     	; 0xd08 <API_GetRom+0xe2>
			return ERR_NO_INFO;
		}
		
		uint16_t banks = GetRomBanks(gameInfo.RomSizeFlag);
     ccc:	80 91 99 01 	lds	r24, 0x0199
     cd0:	8a dc       	rcall	.-1772   	; 0x5e6 <GetRomBanks>
     cd2:	7c 01       	movw	r14, r24
     cd4:	c0 e0       	ldi	r28, 0x00	; 0
     cd6:	d0 e0       	ldi	r29, 0x00	; 0
     cd8:	01 e0       	ldi	r16, 0x01	; 1
     cda:	10 e0       	ldi	r17, 0x00	; 0
     cdc:	0e c0       	rjmp	.+28     	; 0xcfa <API_GetRom+0xd4>
		
		uint16_t addr = 0;
		for(uint16_t bank = 1;bank < banks;bank++)
		{
			SwitchROMBank(bank);
     cde:	80 2f       	mov	r24, r16
     ce0:	50 dd       	rcall	.-1376   	; 0x782 <SwitchROMBank>
     ce2:	05 c0       	rjmp	.+10     	; 0xcee <API_GetRom+0xc8>
			for(;addr < 0x8000;addr++)
			{
				cprintf_char(ReadByte(addr));
     ce4:	81 e0       	ldi	r24, 0x01	; 1
     ce6:	be 01       	movw	r22, r28
     ce8:	ad dd       	rcall	.-1190   	; 0x844 <_ReadByte>
     cea:	88 d1       	rcall	.+784    	; 0xffc <cprintf_char>
		
		uint16_t addr = 0;
		for(uint16_t bank = 1;bank < banks;bank++)
		{
			SwitchROMBank(bank);
			for(;addr < 0x8000;addr++)
     cec:	21 96       	adiw	r28, 0x01	; 1
     cee:	d7 ff       	sbrs	r29, 7
     cf0:	f9 cf       	rjmp	.-14     	; 0xce4 <API_GetRom+0xbe>
		}
		
		uint16_t banks = GetRomBanks(gameInfo.RomSizeFlag);
		
		uint16_t addr = 0;
		for(uint16_t bank = 1;bank < banks;bank++)
     cf2:	0f 5f       	subi	r16, 0xFF	; 255
     cf4:	1f 4f       	sbci	r17, 0xFF	; 255
     cf6:	c0 e0       	ldi	r28, 0x00	; 0
     cf8:	d0 e4       	ldi	r29, 0x40	; 64
     cfa:	0e 15       	cp	r16, r14
     cfc:	1f 05       	cpc	r17, r15
     cfe:	78 f3       	brcs	.-34     	; 0xcde <API_GetRom+0xb8>
void API_ResetGameInfo(void)
{
	//reset GameInfo
	//code only checks byte 0 of the name. invalidate that and its ok :P
	//this produces smaller code too xD
	gameInfo.Name[0] = 0xFF;
     d00:	8f ef       	ldi	r24, 0xFF	; 255
     d02:	80 93 87 01 	sts	0x0187, r24
     d06:	81 e0       	ldi	r24, 0x01	; 1
		}			
	}	
	
	API_ResetGameInfo();
	return 1;
}
     d08:	df 91       	pop	r29
     d0a:	cf 91       	pop	r28
     d0c:	1f 91       	pop	r17
     d0e:	0f 91       	pop	r16
     d10:	ff 90       	pop	r15
     d12:	ef 90       	pop	r14
     d14:	df 90       	pop	r13
     d16:	cf 90       	pop	r12
     d18:	bf 90       	pop	r11
     d1a:	af 90       	pop	r10
     d1c:	9f 90       	pop	r9
     d1e:	8f 90       	pop	r8
     d20:	08 95       	ret

00000d22 <API_WaitForOK>:
		Setup_GB_Pins();
	}
	return;
}
int8_t API_WaitForOK(void)
{
     d22:	1f 93       	push	r17
	//disable interrupts, like serial interrupt for example :P 
	//we will handle the data, kthxbye
	DisableSerialInterrupt();
     d24:	8c d1       	rcall	.+792    	; 0x103e <DisableSerialInterrupt>
	int8_t ret = 0;
	
	cprintf_char(API_OK);
     d26:	80 e1       	ldi	r24, 0x10	; 16
     d28:	69 d1       	rcall	.+722    	; 0xffc <cprintf_char>
	uint8_t response = Serial_ReadByte();
     d2a:	81 d1       	rcall	.+770    	; 0x102e <Serial_ReadByte>
	
	switch(response)
     d2c:	80 31       	cpi	r24, 0x10	; 16
     d2e:	31 f0       	breq	.+12     	; 0xd3c <API_WaitForOK+0x1a>
     d30:	80 3f       	cpi	r24, 0xF0	; 240
     d32:	11 f4       	brne	.+4      	; 0xd38 <API_WaitForOK+0x16>
     d34:	1f ef       	ldi	r17, 0xFF	; 255
     d36:	03 c0       	rjmp	.+6      	; 0xd3e <API_WaitForOK+0x1c>
     d38:	10 e0       	ldi	r17, 0x00	; 0
     d3a:	01 c0       	rjmp	.+2      	; 0xd3e <API_WaitForOK+0x1c>
     d3c:	11 e0       	ldi	r17, 0x01	; 1
		case API_OK:
			ret = 1;
			break;
	}
	
	EnableSerialInterrupt();
     d3e:	84 d1       	rcall	.+776    	; 0x1048 <EnableSerialInterrupt>
	return ret;
}
     d40:	81 2f       	mov	r24, r17
     d42:	1f 91       	pop	r17
     d44:	08 95       	ret

00000d46 <API_WriteGBRam>:
		return ERR_NOK_RETURNED;
	}
	return 1;
}
int8_t API_WriteGBRam(void)
{	
     d46:	ef 92       	push	r14
     d48:	ff 92       	push	r15
     d4a:	0f 93       	push	r16
     d4c:	1f 93       	push	r17
     d4e:	df 93       	push	r29
     d50:	cf 93       	push	r28
     d52:	00 d0       	rcall	.+0      	; 0xd54 <API_WriteGBRam+0xe>
     d54:	0f 92       	push	r0
     d56:	cd b7       	in	r28, 0x3d	; 61
     d58:	de b7       	in	r29, 0x3e	; 62
	if(_gba_cart)
     d5a:	80 91 47 01 	lds	r24, 0x0147
     d5e:	88 23       	and	r24, r24
     d60:	11 f0       	breq	.+4      	; 0xd66 <API_WriteGBRam+0x20>
     d62:	1f ef       	ldi	r17, 0xFF	; 255
     d64:	9a c0       	rjmp	.+308    	; 0xe9a <API_WriteGBRam+0x154>
	{
		return -1;
	}
	
	//reset game cart. this causes all banks & states to reset
	ClearPin(CTRL_PORT,CS2);
     d66:	93 98       	cbi	0x12, 3	; 18
	SetPin(CTRL_PORT,CS2);
     d68:	93 9a       	sbi	0x12, 3	; 18
	
	gameInfo.fileSize = 0;
     d6a:	10 92 9b 01 	sts	0x019B, r1
     d6e:	10 92 9c 01 	sts	0x019C, r1
     d72:	10 92 9d 01 	sts	0x019D, r1
     d76:	10 92 9e 01 	sts	0x019E, r1
	int8_t ret = 0;
	uint16_t addr = 0xA000;
	uint16_t end_addr = 0xC000;
     d7a:	80 e0       	ldi	r24, 0x00	; 0
     d7c:	90 ec       	ldi	r25, 0xC0	; 192
     d7e:	9b 83       	std	Y+3, r25	; 0x03
     d80:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t banks = 0;
     d82:	19 82       	std	Y+1, r1	; 0x01
	
	if(GetRamDetails(&end_addr,&banks,gameInfo.RamSize) < 0)
     d84:	ce 01       	movw	r24, r28
     d86:	02 96       	adiw	r24, 0x02	; 2
     d88:	be 01       	movw	r22, r28
     d8a:	6f 5f       	subi	r22, 0xFF	; 255
     d8c:	7f 4f       	sbci	r23, 0xFF	; 255
     d8e:	40 91 9a 01 	lds	r20, 0x019A
     d92:	47 dc       	rcall	.-1906   	; 0x622 <GetRamDetails>
     d94:	87 ff       	sbrs	r24, 7
     d96:	04 c0       	rjmp	.+8      	; 0xda0 <API_WriteGBRam+0x5a>
	{	
		API_Send_Abort(API_ABORT_CMD);
     d98:	82 ef       	ldi	r24, 0xF2	; 242
     d9a:	ac de       	rcall	.-680    	; 0xaf4 <API_Send_Abort>
     d9c:	13 ee       	ldi	r17, 0xE3	; 227
     d9e:	78 c0       	rjmp	.+240    	; 0xe90 <API_WriteGBRam+0x14a>
		goto end_function;
	}
		
	//precheck and send everything
	//for WRITERAM we need to send Ram size, wait for the OK(0x80) or NOK(anything NOT 0x80) signal, and then start receiving.
	if(end_addr < 0xC000)
     da0:	8a 81       	ldd	r24, Y+2	; 0x02
     da2:	9b 81       	ldd	r25, Y+3	; 0x03
     da4:	20 ec       	ldi	r18, 0xC0	; 192
     da6:	80 30       	cpi	r24, 0x00	; 0
     da8:	92 07       	cpc	r25, r18
     daa:	28 f4       	brcc	.+10     	; 0xdb6 <API_WriteGBRam+0x70>
	{
		gameInfo.fileSize = end_addr - 0xA000;
     dac:	80 50       	subi	r24, 0x00	; 0
     dae:	90 4a       	sbci	r25, 0xA0	; 160
     db0:	a0 e0       	ldi	r26, 0x00	; 0
     db2:	b0 e0       	ldi	r27, 0x00	; 0
     db4:	0a c0       	rjmp	.+20     	; 0xdca <API_WriteGBRam+0x84>
	}
	else
	{
		gameInfo.fileSize = 0x2000 * banks;
     db6:	29 81       	ldd	r18, Y+1	; 0x01
     db8:	92 2f       	mov	r25, r18
     dba:	92 95       	swap	r25
     dbc:	99 0f       	add	r25, r25
     dbe:	90 7e       	andi	r25, 0xE0	; 224
     dc0:	80 e0       	ldi	r24, 0x00	; 0
     dc2:	aa 27       	eor	r26, r26
     dc4:	97 fd       	sbrc	r25, 7
     dc6:	a0 95       	com	r26
     dc8:	ba 2f       	mov	r27, r26
     dca:	80 93 9b 01 	sts	0x019B, r24
     dce:	90 93 9c 01 	sts	0x019C, r25
     dd2:	a0 93 9d 01 	sts	0x019D, r26
     dd6:	b0 93 9e 01 	sts	0x019E, r27
	}
	
	API_Send_Size();
     dda:	71 de       	rcall	.-798    	; 0xabe <API_Send_Size>
	if(API_WaitForOK() <= 0)
     ddc:	a2 df       	rcall	.-188    	; 0xd22 <API_WaitForOK>
     dde:	18 16       	cp	r1, r24
     de0:	24 f0       	brlt	.+8      	; 0xdea <API_WriteGBRam+0xa4>
	{
		API_Send_Abort(API_ABORT_CMD);
     de2:	82 ef       	ldi	r24, 0xF2	; 242
     de4:	87 de       	rcall	.-754    	; 0xaf4 <API_Send_Abort>
     de6:	19 ef       	ldi	r17, 0xF9	; 249
     de8:	53 c0       	rjmp	.+166    	; 0xe90 <API_WriteGBRam+0x14a>
		goto end_function;
	}
	
	
	//we got the OK!	
	OpenRam();
     dea:	f0 dd       	rcall	.-1056   	; 0x9cc <OpenRam>
	//if we get an NOK + byte -> use that byte to write to the same address again, and send a VERIFY again
	//if we get different data then expected, ABBANDON SHIP!!
	*/
	
	//send the Start, we are ready for loop!
	cprintf_char(API_TASK_START);
     dec:	80 e2       	ldi	r24, 0x20	; 32
     dee:	06 d1       	rcall	.+524    	; 0xffc <cprintf_char>
	uint8_t data_recv[2];
	uint8_t bank = 0;
	ret = 1;
	
	//switch bank!
	if(LoadedBankType != MBC2)
     df0:	80 91 65 01 	lds	r24, 0x0165
     df4:	80 32       	cpi	r24, 0x20	; 32
     df6:	11 f0       	breq	.+4      	; 0xdfc <API_WriteGBRam+0xb6>
		SwitchRAMBank(bank);
     df8:	80 e0       	ldi	r24, 0x00	; 0
     dfa:	bd dc       	rcall	.-1670   	; 0x776 <SwitchRAMBank>
	
	//disable interrupts, like serial interrupt for example :P 
	//we will handle the data, kthxbye
	DisableSerialInterrupt();
     dfc:	20 d1       	rcall	.+576    	; 0x103e <DisableSerialInterrupt>
     dfe:	00 e0       	ldi	r16, 0x00	; 0
     e00:	6f ef       	ldi	r22, 0xFF	; 255
     e02:	e6 2e       	mov	r14, r22
     e04:	6f e9       	ldi	r22, 0x9F	; 159
     e06:	f6 2e       	mov	r15, r22
     e08:	39 c0       	rjmp	.+114    	; 0xe7c <API_WriteGBRam+0x136>
	
	//we start our loop at addr -1 because we will add 1 asa we start the loop
	for(uint16_t i = addr-1;i< end_addr;)
	{		
		//receive first byte
		while ( !(UCSRA & (_BV(RXC))) );	
     e0a:	5f 9b       	sbis	0x0b, 7	; 11
     e0c:	fe cf       	rjmp	.-4      	; 0xe0a <API_WriteGBRam+0xc4>
		//add the delay because the while tends to exit once in a while to early and it makes us retrieve the wrong byte. for example 0xFA often tended to become 00.
		asm ("nop");
     e0e:	00 00       	nop
		data_recv[0] = UDR;
     e10:	2c b1       	in	r18, 0x0c	; 12
		
		//second byte
		while ( !(UCSRA & (_BV(RXC))) );	
     e12:	5f 9b       	sbis	0x0b, 7	; 11
     e14:	fe cf       	rjmp	.-4      	; 0xe12 <API_WriteGBRam+0xcc>
		asm ("nop");
     e16:	00 00       	nop
		data_recv[1] = UDR;
     e18:	1c b1       	in	r17, 0x0c	; 12
		
		//check wether we got an OK signal (meaning we can start to write or data written is OK
		if(data_recv[0] == API_OK)
     e1a:	20 31       	cpi	r18, 0x10	; 16
     e1c:	e1 f4       	brne	.+56     	; 0xe56 <API_WriteGBRam+0x110>
		{
			//go to next address!
			i++;
     e1e:	08 94       	sec
     e20:	e1 1c       	adc	r14, r1
     e22:	f1 1c       	adc	r15, r1
			//if we are at the end of our RAM address, and there are more banks, go to next bank!
			if(i >= end_addr && bank < banks)
     e24:	e8 16       	cp	r14, r24
     e26:	f9 06       	cpc	r15, r25
     e28:	68 f0       	brcs	.+26     	; 0xe44 <API_WriteGBRam+0xfe>
     e2a:	89 81       	ldd	r24, Y+1	; 0x01
     e2c:	08 17       	cp	r16, r24
     e2e:	50 f4       	brcc	.+20     	; 0xe44 <API_WriteGBRam+0xfe>
			{
				bank++;
     e30:	0f 5f       	subi	r16, 0xFF	; 255
				i = addr;
				if(LoadedBankType != MBC2)
     e32:	80 91 65 01 	lds	r24, 0x0165
     e36:	80 32       	cpi	r24, 0x20	; 32
     e38:	11 f0       	breq	.+4      	; 0xe3e <API_WriteGBRam+0xf8>
					SwitchRAMBank(bank);	
     e3a:	80 2f       	mov	r24, r16
     e3c:	9c dc       	rcall	.-1736   	; 0x776 <SwitchRAMBank>
     e3e:	e1 2c       	mov	r14, r1
     e40:	50 ea       	ldi	r21, 0xA0	; 160
     e42:	f5 2e       	mov	r15, r21
			}
			
			//if we have written everything , on all banks , gtfo. we are done
			if(i >= end_addr || bank >= banks)
     e44:	8a 81       	ldd	r24, Y+2	; 0x02
     e46:	9b 81       	ldd	r25, Y+3	; 0x03
     e48:	e8 16       	cp	r14, r24
     e4a:	f9 06       	cpc	r15, r25
     e4c:	e8 f4       	brcc	.+58     	; 0xe88 <API_WriteGBRam+0x142>
     e4e:	89 81       	ldd	r24, Y+1	; 0x01
     e50:	08 17       	cp	r16, r24
     e52:	18 f0       	brcs	.+6      	; 0xe5a <API_WriteGBRam+0x114>
     e54:	19 c0       	rjmp	.+50     	; 0xe88 <API_WriteGBRam+0x142>
			uint8_t data = ReadRAMByte(i);
			
			cprintf_char(API_VERIFY);
			cprintf_char(data);
		}
		else if(data_recv[0] == API_NOK)
     e56:	21 31       	cpi	r18, 0x11	; 17
     e58:	59 f4       	brne	.+22     	; 0xe70 <API_WriteGBRam+0x12a>
		{
			//data was decided NOT OK, we go back and retry!
			WriteRAMByte(i,data_recv[1]);			
     e5a:	c7 01       	movw	r24, r14
     e5c:	61 2f       	mov	r22, r17
     e5e:	e3 dc       	rcall	.-1594   	; 0x826 <WriteRAMByte>
			uint8_t data = ReadRAMByte(i);
     e60:	c7 01       	movw	r24, r14
     e62:	d5 dd       	rcall	.-1110   	; 0xa0e <ReadRAMByte>
     e64:	18 2f       	mov	r17, r24
			cprintf_char(API_VERIFY);
     e66:	82 e1       	ldi	r24, 0x12	; 18
     e68:	c9 d0       	rcall	.+402    	; 0xffc <cprintf_char>
			cprintf_char(data);
     e6a:	81 2f       	mov	r24, r17
     e6c:	c7 d0       	rcall	.+398    	; 0xffc <cprintf_char>
     e6e:	06 c0       	rjmp	.+12     	; 0xe7c <API_WriteGBRam+0x136>
		}
		else
		{
			//we received an abort or invalid command. QUIT!!
			ret = ERR_PACKET_FAILURE;
			cprintf_char(API_ABORT);
     e70:	80 ef       	ldi	r24, 0xF0	; 240
     e72:	c4 d0       	rcall	.+392    	; 0xffc <cprintf_char>
			cprintf_char(API_ABORT_PACKET);
     e74:	83 ef       	ldi	r24, 0xF3	; 243
     e76:	c2 d0       	rcall	.+388    	; 0xffc <cprintf_char>
     e78:	1a ef       	ldi	r17, 0xFA	; 250
     e7a:	07 c0       	rjmp	.+14     	; 0xe8a <API_WriteGBRam+0x144>
	//disable interrupts, like serial interrupt for example :P 
	//we will handle the data, kthxbye
	DisableSerialInterrupt();
	
	//we start our loop at addr -1 because we will add 1 asa we start the loop
	for(uint16_t i = addr-1;i< end_addr;)
     e7c:	8a 81       	ldd	r24, Y+2	; 0x02
     e7e:	9b 81       	ldd	r25, Y+3	; 0x03
     e80:	e8 16       	cp	r14, r24
     e82:	f9 06       	cpc	r15, r25
     e84:	08 f4       	brcc	.+2      	; 0xe88 <API_WriteGBRam+0x142>
     e86:	c1 cf       	rjmp	.-126    	; 0xe0a <API_WriteGBRam+0xc4>
     e88:	11 e0       	ldi	r17, 0x01	; 1
			cprintf_char(API_ABORT_PACKET);
			break;
		}
	}
	//we are finished, lets send that!
	cprintf_char(API_TASK_FINISHED);
     e8a:	81 e2       	ldi	r24, 0x21	; 33
     e8c:	b7 d0       	rcall	.+366    	; 0xffc <cprintf_char>
	
	CloseRam();
     e8e:	bc dc       	rcall	.-1672   	; 0x808 <CloseRam>
end_function:
	//re-enable interrupts!
	ClearPin(CTRL_PORT,CS2);
     e90:	93 98       	cbi	0x12, 3	; 18
void API_ResetGameInfo(void)
{
	//reset GameInfo
	//code only checks byte 0 of the name. invalidate that and its ok :P
	//this produces smaller code too xD
	gameInfo.Name[0] = 0xFF;
     e92:	8f ef       	ldi	r24, 0xFF	; 255
     e94:	80 93 87 01 	sts	0x0187, r24
	CloseRam();
end_function:
	//re-enable interrupts!
	ClearPin(CTRL_PORT,CS2);
	API_ResetGameInfo();
	EnableSerialInterrupt();
     e98:	d7 d0       	rcall	.+430    	; 0x1048 <EnableSerialInterrupt>
	return ret;
}
     e9a:	81 2f       	mov	r24, r17
     e9c:	0f 90       	pop	r0
     e9e:	0f 90       	pop	r0
     ea0:	0f 90       	pop	r0
     ea2:	cf 91       	pop	r28
     ea4:	df 91       	pop	r29
     ea6:	1f 91       	pop	r17
     ea8:	0f 91       	pop	r16
     eaa:	ff 90       	pop	r15
     eac:	ef 90       	pop	r14
     eae:	08 95       	ret

00000eb0 <API_WriteRam>:
int8_t API_WriteRam(void)
{		
     eb0:	1f 93       	push	r17
	int8_t ret = API_GetGameInfo();
     eb2:	3d de       	rcall	.-902    	; 0xb2e <API_GetGameInfo>
     eb4:	18 2f       	mov	r17, r24
	if(!ret)
     eb6:	88 23       	and	r24, r24
     eb8:	19 f4       	brne	.+6      	; 0xec0 <API_WriteRam+0x10>
	{
		API_Send_Abort(API_ABORT_CMD);
     eba:	82 ef       	ldi	r24, 0xF2	; 242
     ebc:	1b de       	rcall	.-970    	; 0xaf4 <API_Send_Abort>
     ebe:	0c c0       	rjmp	.+24     	; 0xed8 <API_WriteRam+0x28>
		return ret;
	}
	
	SetPin(CTRL_PORT,WD);
     ec0:	96 9a       	sbi	0x12, 6	; 18
	SetPin(CTRL_PORT,RD);
     ec2:	95 9a       	sbi	0x12, 5	; 18
	SetPin(CTRL_PORT,CS1);
     ec4:	97 9a       	sbi	0x12, 7	; 18
	SetPin(CTRL_PORT,CS2);
     ec6:	93 9a       	sbi	0x12, 3	; 18
	
	if(_gba_cart)
     ec8:	80 91 47 01 	lds	r24, 0x0147
     ecc:	88 23       	and	r24, r24
     ece:	11 f0       	breq	.+4      	; 0xed4 <API_WriteRam+0x24>
     ed0:	10 e0       	ldi	r17, 0x00	; 0
     ed2:	02 c0       	rjmp	.+4      	; 0xed8 <API_WriteRam+0x28>
	{
		return 0;
	}
	else
	{
		return API_WriteGBRam();
     ed4:	38 df       	rcall	.-400    	; 0xd46 <API_WriteGBRam>
     ed6:	18 2f       	mov	r17, r24
	}
}
     ed8:	81 2f       	mov	r24, r17
     eda:	1f 91       	pop	r17
     edc:	08 95       	ret

00000ede <API_Get_Memory>:
int8_t API_CartInserted(void)
{
	return (gameInfo.Name[0] == 0xFF)?0:1;
}
int8_t API_Get_Memory(ROM_TYPE type)
{
     ede:	1f 93       	push	r17
     ee0:	df 93       	push	r29
     ee2:	cf 93       	push	r28
     ee4:	00 d0       	rcall	.+0      	; 0xee6 <API_Get_Memory+0x8>
     ee6:	0f 92       	push	r0
     ee8:	cd b7       	in	r28, 0x3d	; 61
     eea:	de b7       	in	r29, 0x3e	; 62
     eec:	18 2f       	mov	r17, r24
	uint8_t ret = API_GetGameInfo();
     eee:	1f de       	rcall	.-962    	; 0xb2e <API_GetGameInfo>
	if(!ret)
     ef0:	88 23       	and	r24, r24
     ef2:	21 f4       	brne	.+8      	; 0xefc <API_Get_Memory+0x1e>
	{
		API_Send_Abort(API_ABORT_CMD);
     ef4:	82 ef       	ldi	r24, 0xF2	; 242
     ef6:	fe dd       	rcall	.-1028   	; 0xaf4 <API_Send_Abort>
     ef8:	80 e0       	ldi	r24, 0x00	; 0
     efa:	5b c0       	rjmp	.+182    	; 0xfb2 <API_Get_Memory+0xd4>
     efc:	80 91 47 01 	lds	r24, 0x0147
		return ret;
	}
			
	if(type == TYPE_ROM)
     f00:	11 23       	and	r17, r17
     f02:	c9 f4       	brne	.+50     	; 0xf36 <API_Get_Memory+0x58>
	{
		if(_gba_cart)
     f04:	88 23       	and	r24, r24
     f06:	51 f0       	breq	.+20     	; 0xf1c <API_Get_Memory+0x3e>
		{
			gameInfo.fileSize = GetGBARomSize();
     f08:	7f da       	rcall	.-2818   	; 0x408 <GetGBARomSize>
     f0a:	60 93 9b 01 	sts	0x019B, r22
     f0e:	70 93 9c 01 	sts	0x019C, r23
     f12:	80 93 9d 01 	sts	0x019D, r24
     f16:	90 93 9e 01 	sts	0x019E, r25
     f1a:	3c c0       	rjmp	.+120    	; 0xf94 <API_Get_Memory+0xb6>
		}
		else
		{
			gameInfo.fileSize = GetRomBanks(gameInfo.RomSizeFlag) * 0x4000UL;
     f1c:	80 91 99 01 	lds	r24, 0x0199
     f20:	62 db       	rcall	.-2364   	; 0x5e6 <GetRomBanks>
     f22:	a0 e0       	ldi	r26, 0x00	; 0
     f24:	b0 e0       	ldi	r27, 0x00	; 0
     f26:	7e e0       	ldi	r23, 0x0E	; 14
     f28:	88 0f       	add	r24, r24
     f2a:	99 1f       	adc	r25, r25
     f2c:	aa 1f       	adc	r26, r26
     f2e:	bb 1f       	adc	r27, r27
     f30:	7a 95       	dec	r23
     f32:	d1 f7       	brne	.-12     	; 0xf28 <API_Get_Memory+0x4a>
     f34:	27 c0       	rjmp	.+78     	; 0xf84 <API_Get_Memory+0xa6>
		}		
	}
	else
	{
		if(_gba_cart)
     f36:	88 23       	and	r24, r24
     f38:	69 f5       	brne	.+90     	; 0xf94 <API_Get_Memory+0xb6>
		{
			
		}
		else
		{
			uint16_t end_addr = 0;
     f3a:	1b 82       	std	Y+3, r1	; 0x03
     f3c:	1a 82       	std	Y+2, r1	; 0x02
			uint8_t _banks;
			
			if(GetRamDetails(&end_addr, &_banks,gameInfo.RamSize) < 0)
     f3e:	ce 01       	movw	r24, r28
     f40:	02 96       	adiw	r24, 0x02	; 2
     f42:	be 01       	movw	r22, r28
     f44:	6f 5f       	subi	r22, 0xFF	; 255
     f46:	7f 4f       	sbci	r23, 0xFF	; 255
     f48:	40 91 9a 01 	lds	r20, 0x019A
     f4c:	6a db       	rcall	.-2348   	; 0x622 <GetRamDetails>
     f4e:	87 ff       	sbrs	r24, 7
     f50:	04 c0       	rjmp	.+8      	; 0xf5a <API_Get_Memory+0x7c>
			{
				//ram error, BAIL IT
				API_Send_Abort(API_ABORT_CMD);
     f52:	82 ef       	ldi	r24, 0xF2	; 242
     f54:	cf dd       	rcall	.-1122   	; 0xaf4 <API_Send_Abort>
     f56:	83 ee       	ldi	r24, 0xE3	; 227
     f58:	2c c0       	rjmp	.+88     	; 0xfb2 <API_Get_Memory+0xd4>
				return ERR_NO_SAVE;
			}
			
			if(end_addr < 0xC000)
     f5a:	8a 81       	ldd	r24, Y+2	; 0x02
     f5c:	9b 81       	ldd	r25, Y+3	; 0x03
     f5e:	20 ec       	ldi	r18, 0xC0	; 192
     f60:	80 30       	cpi	r24, 0x00	; 0
     f62:	92 07       	cpc	r25, r18
     f64:	28 f4       	brcc	.+10     	; 0xf70 <API_Get_Memory+0x92>
			{
				gameInfo.fileSize = end_addr - 0xA000;
     f66:	80 50       	subi	r24, 0x00	; 0
     f68:	90 4a       	sbci	r25, 0xA0	; 160
     f6a:	a0 e0       	ldi	r26, 0x00	; 0
     f6c:	b0 e0       	ldi	r27, 0x00	; 0
     f6e:	0a c0       	rjmp	.+20     	; 0xf84 <API_Get_Memory+0xa6>
			}
			else
			{
				gameInfo.fileSize = 0x2000 * _banks;
     f70:	29 81       	ldd	r18, Y+1	; 0x01
     f72:	92 2f       	mov	r25, r18
     f74:	92 95       	swap	r25
     f76:	99 0f       	add	r25, r25
     f78:	90 7e       	andi	r25, 0xE0	; 224
     f7a:	80 e0       	ldi	r24, 0x00	; 0
     f7c:	aa 27       	eor	r26, r26
     f7e:	97 fd       	sbrc	r25, 7
     f80:	a0 95       	com	r26
     f82:	ba 2f       	mov	r27, r26
     f84:	80 93 9b 01 	sts	0x019B, r24
     f88:	90 93 9c 01 	sts	0x019C, r25
     f8c:	a0 93 9d 01 	sts	0x019D, r26
     f90:	b0 93 9e 01 	sts	0x019E, r27
			}
		}		
	}
	
	API_Send_Cart_Type();
     f94:	75 dd       	rcall	.-1302   	; 0xa80 <API_Send_Cart_Type>
	API_Send_Name();
     f96:	b9 dd       	rcall	.-1166   	; 0xb0a <API_Send_Name>
	API_Send_Size();
     f98:	92 dd       	rcall	.-1244   	; 0xabe <API_Send_Size>
	
	
	if(API_WaitForOK() > 0)
     f9a:	c3 de       	rcall	.-634    	; 0xd22 <API_WaitForOK>
     f9c:	18 16       	cp	r1, r24
     f9e:	34 f4       	brge	.+12     	; 0xfac <API_Get_Memory+0xce>
	{
		if(type == TYPE_RAM)
     fa0:	11 30       	cpi	r17, 0x01	; 1
     fa2:	11 f4       	brne	.+4      	; 0xfa8 <API_Get_Memory+0xca>
		{
			return API_GetRam();
     fa4:	e7 dd       	rcall	.-1074   	; 0xb74 <API_GetRam>
     fa6:	05 c0       	rjmp	.+10     	; 0xfb2 <API_Get_Memory+0xd4>
		}
		else
		{
			return API_GetRom();
     fa8:	3e de       	rcall	.-900    	; 0xc26 <API_GetRom>
     faa:	03 c0       	rjmp	.+6      	; 0xfb2 <API_Get_Memory+0xd4>
		}
	}
	else
	{
		API_Send_Abort(API_ABORT_PACKET);
     fac:	83 ef       	ldi	r24, 0xF3	; 243
     fae:	a2 dd       	rcall	.-1212   	; 0xaf4 <API_Send_Abort>
     fb0:	89 ef       	ldi	r24, 0xF9	; 249
		return ERR_NOK_RETURNED;
	}
	return 1;
}
     fb2:	0f 90       	pop	r0
     fb4:	0f 90       	pop	r0
     fb6:	0f 90       	pop	r0
     fb8:	cf 91       	pop	r28
     fba:	df 91       	pop	r29
     fbc:	1f 91       	pop	r17
     fbe:	08 95       	ret

00000fc0 <API_SetupPins>:
{
	API_SetupPins(1);
	API_ResetGameInfo();
}
void API_SetupPins(int8_t _gba_mode)
{
     fc0:	48 2f       	mov	r20, r24
	if(_gba_mode == _gba_cart)
     fc2:	28 2f       	mov	r18, r24
     fc4:	33 27       	eor	r19, r19
     fc6:	27 fd       	sbrc	r18, 7
     fc8:	30 95       	com	r19
     fca:	80 91 47 01 	lds	r24, 0x0147
     fce:	90 e0       	ldi	r25, 0x00	; 0
     fd0:	28 17       	cp	r18, r24
     fd2:	39 07       	cpc	r19, r25
     fd4:	39 f0       	breq	.+14     	; 0xfe4 <API_SetupPins+0x24>
		return;
	
	_gba_cart = _gba_mode;
     fd6:	40 93 47 01 	sts	0x0147, r20
	
	if(_gba_cart)
     fda:	44 23       	and	r20, r20
     fdc:	11 f0       	breq	.+4      	; 0xfe2 <API_SetupPins+0x22>
	{
		Setup_GBA_Pins();
     fde:	c1 da       	rcall	.-2686   	; 0x562 <Setup_GBA_Pins>
     fe0:	08 95       	ret
	}
	else
	{
		Setup_GB_Pins();
     fe2:	28 dd       	rcall	.-1456   	; 0xa34 <Setup_GB_Pins>
     fe4:	08 95       	ret

00000fe6 <API_Init>:

uint8_t _gba_cart = 2;

void API_Init(void)
{
	API_SetupPins(1);
     fe6:	81 e0       	ldi	r24, 0x01	; 1
     fe8:	eb df       	rcall	.-42     	; 0xfc0 <API_SetupPins>
void API_ResetGameInfo(void)
{
	//reset GameInfo
	//code only checks byte 0 of the name. invalidate that and its ok :P
	//this produces smaller code too xD
	gameInfo.Name[0] = 0xFF;
     fea:	8f ef       	ldi	r24, 0xFF	; 255
     fec:	80 93 87 01 	sts	0x0187, r24

void API_Init(void)
{
	API_SetupPins(1);
	API_ResetGameInfo();
}
     ff0:	08 95       	ret

00000ff2 <setSerialRecvCallback>:
void (*cb_recv)(char); 

//Override the Recv callback, or return it to default by giving NULL
void setSerialRecvCallback(void* cb)
{
	cb_recv = cb;
     ff2:	90 93 a1 01 	sts	0x01A1, r25
     ff6:	80 93 a0 01 	sts	0x01A0, r24
}
     ffa:	08 95       	ret

00000ffc <cprintf_char>:

//Send a Char to the Other side
void usart_SendChar(char data) 
{
     ffc:	98 2f       	mov	r25, r24
	if(_serial_init == 0)
     ffe:	80 91 54 01 	lds	r24, 0x0154
    1002:	88 23       	and	r24, r24
    1004:	19 f0       	breq	.+6      	; 0x100c <cprintf_char+0x10>
		return;
	
    // Wait for empty transmit buffer
    while ( !(UCSRA & (_BV(UDRE))) );
    1006:	5d 9b       	sbis	0x0b, 5	; 11
    1008:	fe cf       	rjmp	.-4      	; 0x1006 <cprintf_char+0xa>
    // Start transmission
    UDR = data;
    100a:	9c b9       	out	0x0c, r25	; 12
    100c:	08 95       	ret

0000100e <cprintf_string>:
}

//Send a string to the other side
void usart_SendString(char *s) {
    100e:	fc 01       	movw	r30, r24
	
	if(_serial_init == 0 || s == NULL)
    1010:	80 91 54 01 	lds	r24, 0x0154
    1014:	88 23       	and	r24, r24
    1016:	51 f0       	breq	.+20     	; 0x102c <cprintf_string+0x1e>
    1018:	30 97       	sbiw	r30, 0x00	; 0
    101a:	29 f4       	brne	.+10     	; 0x1026 <cprintf_string+0x18>
    101c:	08 95       	ret
{
	if(_serial_init == 0)
		return;
	
    // Wait for empty transmit buffer
    while ( !(UCSRA & (_BV(UDRE))) );
    101e:	5d 9b       	sbis	0x0b, 5	; 11
    1020:	fe cf       	rjmp	.-4      	; 0x101e <cprintf_string+0x10>
    // Start transmission
    UDR = data;
    1022:	8c b9       	out	0x0c, r24	; 12
	}

    // loop through entire string
    while (*s) {
        usart_SendChar(*s);
        s++; 
    1024:	31 96       	adiw	r30, 0x01	; 1
	{
		return;
	}

    // loop through entire string
    while (*s) {
    1026:	80 81       	ld	r24, Z
    1028:	88 23       	and	r24, r24
    102a:	c9 f7       	brne	.-14     	; 0x101e <cprintf_string+0x10>
    102c:	08 95       	ret

0000102e <Serial_ReadByte>:

//Wait untill a single Char is received
//kinda useless as we have the interrupt xD
unsigned char usart_GetChar(void) 
{
	if(_serial_init == 0)
    102e:	80 91 54 01 	lds	r24, 0x0154
    1032:	88 23       	and	r24, r24
    1034:	19 f0       	breq	.+6      	; 0x103c <Serial_ReadByte+0xe>
		return 0x00;
	
    // Wait for incoming data
    while ( !(UCSRA & (_BV(RXC))) );
    1036:	5f 9b       	sbis	0x0b, 7	; 11
    1038:	fe cf       	rjmp	.-4      	; 0x1036 <Serial_ReadByte+0x8>
    // Return the data
    return UDR;
    103a:	8c b1       	in	r24, 0x0c	; 12
}
    103c:	08 95       	ret

0000103e <DisableSerialInterrupt>:
void DisableSerialInterrupt(void)
{
	if(_serial_init == 0)
    103e:	80 91 54 01 	lds	r24, 0x0154
    1042:	81 11       	cpse	r24, r1
		return;
	
	UCSRB &= ~(1 << RXCIE);
    1044:	57 98       	cbi	0x0a, 7	; 10
    1046:	08 95       	ret

00001048 <EnableSerialInterrupt>:
}
void EnableSerialInterrupt(void)
{
	if(_serial_init == 0)
    1048:	80 91 54 01 	lds	r24, 0x0154
    104c:	81 11       	cpse	r24, r1
		return;
	
	UCSRB |= (1 << RXCIE);
    104e:	57 9a       	sbi	0x0a, 7	; 10
    1050:	08 95       	ret

00001052 <initConsole>:
}
//Inialise the Console			
void initConsole(void) {
    // Set baud rate
	UBRRH = (uint8_t)(BAUDRATE>>8);
    1052:	10 bc       	out	0x20, r1	; 32
    UBRRL = (uint8_t)BAUDRATE;
    1054:	83 e0       	ldi	r24, 0x03	; 3
    1056:	89 b9       	out	0x09, r24	; 9

    // Enable receiver and transmitter
    UCSRB |= (1<<RXEN)|(1<<TXEN);
    1058:	8a b1       	in	r24, 0x0a	; 10
    105a:	88 61       	ori	r24, 0x18	; 24
    105c:	8a b9       	out	0x0a, r24	; 10
	UCSRA |= (1<<U2X);
    105e:	59 9a       	sbi	0x0b, 1	; 11
	
    // Set frame format: 8data, 1stop bit
    UCSRC |= (1<<URSEL)|(3<<UCSZ0);	
    1060:	80 b5       	in	r24, 0x20	; 32
    1062:	86 68       	ori	r24, 0x86	; 134
    1064:	80 bd       	out	0x20, r24	; 32
	
	cb_recv = usart_SendChar;
    1066:	8e ef       	ldi	r24, 0xFE	; 254
    1068:	97 e0       	ldi	r25, 0x07	; 7
    106a:	90 93 a1 01 	sts	0x01A1, r25
    106e:	80 93 a0 01 	sts	0x01A0, r24
	
	//enable interrupts in the chip, cli(); disables them again
	sei();
    1072:	78 94       	sei
	
	_serial_init = 1;
    1074:	81 e0       	ldi	r24, 0x01	; 1
    1076:	80 93 54 01 	sts	0x0154, r24
void EnableSerialInterrupt(void)
{
	if(_serial_init == 0)
		return;
	
	UCSRB |= (1 << RXCIE);
    107a:	57 9a       	sbi	0x0a, 7	; 10
		
	//enable the receive interrupt
	EnableSerialInterrupt();
	
	return;
}
    107c:	08 95       	ret

0000107e <__vector_11>:
}
#endif

//Interrupt handler of receiving characters
ISR(USART_RXC_vect)
{
    107e:	1f 92       	push	r1
    1080:	0f 92       	push	r0
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	0f 92       	push	r0
    1086:	11 24       	eor	r1, r1
    1088:	2f 93       	push	r18
    108a:	3f 93       	push	r19
    108c:	4f 93       	push	r20
    108e:	5f 93       	push	r21
    1090:	6f 93       	push	r22
    1092:	7f 93       	push	r23
    1094:	8f 93       	push	r24
    1096:	9f 93       	push	r25
    1098:	af 93       	push	r26
    109a:	bf 93       	push	r27
    109c:	ef 93       	push	r30
    109e:	ff 93       	push	r31
	char ReceivedByte;
	//Put received char into the variable
	//we always need to do this, or the interrupt will keep triggering
	ReceivedByte = UDR;
    10a0:	8c b1       	in	r24, 0x0c	; 12

	//Process the given character
	if(cb_recv != NULL)
    10a2:	e0 91 a0 01 	lds	r30, 0x01A0
    10a6:	f0 91 a1 01 	lds	r31, 0x01A1
    10aa:	30 97       	sbiw	r30, 0x00	; 0
    10ac:	09 f0       	breq	.+2      	; 0x10b0 <__vector_11+0x32>
	{
		cb_recv(ReceivedByte);
    10ae:	09 95       	icall
	}
    10b0:	ff 91       	pop	r31
    10b2:	ef 91       	pop	r30
    10b4:	bf 91       	pop	r27
    10b6:	af 91       	pop	r26
    10b8:	9f 91       	pop	r25
    10ba:	8f 91       	pop	r24
    10bc:	7f 91       	pop	r23
    10be:	6f 91       	pop	r22
    10c0:	5f 91       	pop	r21
    10c2:	4f 91       	pop	r20
    10c4:	3f 91       	pop	r19
    10c6:	2f 91       	pop	r18
    10c8:	0f 90       	pop	r0
    10ca:	0f be       	out	0x3f, r0	; 63
    10cc:	0f 90       	pop	r0
    10ce:	1f 90       	pop	r1
    10d0:	18 95       	reti

000010d2 <spi_init_as>:
{
	return spi_init_as(1);				
}

void spi_init_as(int8_t master)
{
    10d2:	ef 92       	push	r14
    10d4:	ff 92       	push	r15
    10d6:	0f 93       	push	r16
    10d8:	1f 93       	push	r17
    10da:	cf 93       	push	r28
    10dc:	df 93       	push	r29
    10de:	08 2f       	mov	r16, r24
	if(_spi_mode != 0)
    10e0:	80 91 55 01 	lds	r24, 0x0155
    10e4:	88 23       	and	r24, r24
    10e6:	09 f0       	breq	.+2      	; 0x10ea <spi_init_as+0x18>
    10e8:	70 c0       	rjmp	.+224    	; 0x11ca <spi_init_as+0xf8>
		return;
	
	uint8_t _ddr = *_spi_ddr;
    10ea:	c0 91 48 01 	lds	r28, 0x0148
    10ee:	d0 91 49 01 	lds	r29, 0x0149
    10f2:	a8 81       	ld	r26, Y
	uint8_t _port = *_spi_port;
    10f4:	e0 91 4a 01 	lds	r30, 0x014A
    10f8:	f0 91 4b 01 	lds	r31, 0x014B
    10fc:	10 81       	ld	r17, Z
    10fe:	20 91 4d 01 	lds	r18, 0x014D
    1102:	b0 91 4e 01 	lds	r27, 0x014E
    1106:	30 91 50 01 	lds	r19, 0x0150
    110a:	40 91 4f 01 	lds	r20, 0x014F
	uint8_t _spcr = 0;
	
	if(master != 0)
    110e:	00 23       	and	r16, r16
    1110:	41 f1       	breq	.+80     	; 0x1162 <spi_init_as+0x90>
	{	
		//Set SS,MOSI & SCK as Output
		_ddr |= ((1<<SS_PIN)|(1<<MOSI_PIN)|(1<<SCK_PIN));  
    1112:	81 e0       	ldi	r24, 0x01	; 1
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	fc 01       	movw	r30, r24
    1118:	02 c0       	rjmp	.+4      	; 0x111e <spi_init_as+0x4c>
    111a:	ee 0f       	add	r30, r30
    111c:	ff 1f       	adc	r31, r31
    111e:	2a 95       	dec	r18
    1120:	e2 f7       	brpl	.-8      	; 0x111a <spi_init_as+0x48>
    1122:	bc 01       	movw	r22, r24
    1124:	02 c0       	rjmp	.+4      	; 0x112a <spi_init_as+0x58>
    1126:	66 0f       	add	r22, r22
    1128:	77 1f       	adc	r23, r23
    112a:	ba 95       	dec	r27
    112c:	e2 f7       	brpl	.-8      	; 0x1126 <spi_init_as+0x54>
    112e:	7c 01       	movw	r14, r24
    1130:	02 c0       	rjmp	.+4      	; 0x1136 <spi_init_as+0x64>
    1132:	ee 0c       	add	r14, r14
    1134:	ff 1c       	adc	r15, r15
    1136:	3a 95       	dec	r19
    1138:	e2 f7       	brpl	.-8      	; 0x1132 <spi_init_as+0x60>
    113a:	97 01       	movw	r18, r14

		//Set MISO as input
		_ddr &= ~(1<<MISO_PIN);
    113c:	02 c0       	rjmp	.+4      	; 0x1142 <spi_init_as+0x70>
    113e:	88 0f       	add	r24, r24
    1140:	99 1f       	adc	r25, r25
    1142:	4a 95       	dec	r20
    1144:	e2 f7       	brpl	.-8      	; 0x113e <spi_init_as+0x6c>
    1146:	3e 2f       	mov	r19, r30
    1148:	36 2b       	or	r19, r22
    114a:	3a 2b       	or	r19, r26
    114c:	32 2b       	or	r19, r18
    114e:	48 2f       	mov	r20, r24
    1150:	40 95       	com	r20
    1152:	34 23       	and	r19, r20
		
		// set MOSI as output LOW & MISO as tristate input
		_port &= ~((1<<MOSI_PIN)|(1<<MISO_PIN)); 
		
		// set CS_PIN , SS HIGH + set pull up of SCK
		_port |= ((1<<SS_PIN)|(1<<SCK_PIN)); 
    1154:	2e 2b       	or	r18, r30
    1156:	86 2b       	or	r24, r22
    1158:	80 95       	com	r24
    115a:	81 23       	and	r24, r17
    115c:	28 2b       	or	r18, r24
    115e:	90 e5       	ldi	r25, 0x50	; 80
    1160:	24 c0       	rjmp	.+72     	; 0x11aa <spi_init_as+0xd8>
		//Set as Master
		_spcr = (1<<SPE)|(1<<MSTR);
	}
	else
	{
		_ddr |= (1<<MISO_PIN);     //MISO as OUTPUT
    1162:	81 e0       	ldi	r24, 0x01	; 1
    1164:	90 e0       	ldi	r25, 0x00	; 0
    1166:	bc 01       	movw	r22, r24
    1168:	02 c0       	rjmp	.+4      	; 0x116e <spi_init_as+0x9c>
    116a:	66 0f       	add	r22, r22
    116c:	77 1f       	adc	r23, r23
    116e:	4a 95       	dec	r20
    1170:	e2 f7       	brpl	.-8      	; 0x116a <spi_init_as+0x98>
    1172:	ab 01       	movw	r20, r22
		_ddr &= ~((1<<SCK_PIN)|(1<<SS_PIN)|(1<<MOSI_PIN));   //SCK,SS,MOSI as INPUT
    1174:	bc 01       	movw	r22, r24
    1176:	02 c0       	rjmp	.+4      	; 0x117c <spi_init_as+0xaa>
    1178:	66 0f       	add	r22, r22
    117a:	77 1f       	adc	r23, r23
    117c:	2a 95       	dec	r18
    117e:	e2 f7       	brpl	.-8      	; 0x1178 <spi_init_as+0xa6>
    1180:	fc 01       	movw	r30, r24
    1182:	02 c0       	rjmp	.+4      	; 0x1188 <spi_init_as+0xb6>
    1184:	ee 0f       	add	r30, r30
    1186:	ff 1f       	adc	r31, r31
    1188:	3a 95       	dec	r19
    118a:	e2 f7       	brpl	.-8      	; 0x1184 <spi_init_as+0xb2>
    118c:	9f 01       	movw	r18, r30
    118e:	36 2f       	mov	r19, r22
    1190:	32 2b       	or	r19, r18
    1192:	02 c0       	rjmp	.+4      	; 0x1198 <spi_init_as+0xc6>
    1194:	88 0f       	add	r24, r24
    1196:	99 1f       	adc	r25, r25
    1198:	ba 95       	dec	r27
    119a:	e2 f7       	brpl	.-8      	; 0x1194 <spi_init_as+0xc2>
    119c:	38 2b       	or	r19, r24
    119e:	30 95       	com	r19
    11a0:	a4 2b       	or	r26, r20
    11a2:	3a 23       	and	r19, r26
		
		_port |= (1<<MISO_PIN);	//set MISO as HIGH
    11a4:	24 2f       	mov	r18, r20
    11a6:	21 2b       	or	r18, r17
    11a8:	90 e4       	ldi	r25, 0x40	; 64
		_spcr = (1<<SPE);    //Enable SPI
	}
	
	*_spi_ddr = _ddr;
    11aa:	38 83       	st	Y, r19
	*_spi_port = _port;
    11ac:	e0 91 4a 01 	lds	r30, 0x014A
    11b0:	f0 91 4b 01 	lds	r31, 0x014B
    11b4:	20 83       	st	Z, r18
	SPSR = (1<<SPI2X);
    11b6:	81 e0       	ldi	r24, 0x01	; 1
    11b8:	8e b9       	out	0x0e, r24	; 14
	SPCR = _spcr;
    11ba:	9d b9       	out	0x0d, r25	; 13
	
	_spi_mode = 1;
    11bc:	80 93 55 01 	sts	0x0155, r24
	if(master == 0)
    11c0:	00 23       	and	r16, r16
    11c2:	19 f4       	brne	.+6      	; 0x11ca <spi_init_as+0xf8>
		_spi_mode++;
    11c4:	82 e0       	ldi	r24, 0x02	; 2
    11c6:	80 93 55 01 	sts	0x0155, r24
	
	return;
}
    11ca:	df 91       	pop	r29
    11cc:	cf 91       	pop	r28
    11ce:	1f 91       	pop	r17
    11d0:	0f 91       	pop	r16
    11d2:	ff 90       	pop	r15
    11d4:	ef 90       	pop	r14
    11d6:	08 95       	ret

000011d8 <spi_init>:
#endif

//Initialize SPI Master Device
void spi_init()
{
	return spi_init_as(1);				
    11d8:	81 e0       	ldi	r24, 0x01	; 1
    11da:	7b df       	rcall	.-266    	; 0x10d2 <spi_init_as>
}
    11dc:	08 95       	ret

000011de <spi_tranceiver_8>:
	return;
}

//Function to send and receive data
inline uint8_t spi_tranceiver_8(uint8_t data)
{
    11de:	98 2f       	mov	r25, r24
	if(_spi_mode == 0)
    11e0:	80 91 55 01 	lds	r24, 0x0155
    11e4:	88 23       	and	r24, r24
    11e6:	21 f0       	breq	.+8      	; 0x11f0 <spi_tranceiver_8+0x12>
		//give the slave some time to set its data
		asm("nop");	              
	}
#endif
	
	SPDR = data; // Load data into the buffer
    11e8:	9f b9       	out	0x0f, r25	; 15
	while(!(SPSR & (1<<SPIF) )); //Wait until transmission complete
    11ea:	77 9b       	sbis	0x0e, 7	; 14
    11ec:	fe cf       	rjmp	.-4      	; 0x11ea <spi_tranceiver_8+0xc>
	data = SPDR; //get data
    11ee:	8f b1       	in	r24, 0x0f	; 15
	}
#endif
	
	//Return received data
	return data; 
}
    11f0:	08 95       	ret

000011f2 <spi_tranceiver>:

inline uint16_t spi_tranceiver(uint16_t data)
{
    11f2:	28 2f       	mov	r18, r24
}

//Function to send and receive data
inline uint8_t spi_tranceiver_8(uint8_t data)
{
	if(_spi_mode == 0)
    11f4:	80 91 55 01 	lds	r24, 0x0155
    11f8:	88 23       	and	r24, r24
    11fa:	19 f4       	brne	.+6      	; 0x1202 <spi_tranceiver+0x10>
    11fc:	20 e0       	ldi	r18, 0x00	; 0
    11fe:	30 e0       	ldi	r19, 0x00	; 0
    1200:	08 c0       	rjmp	.+16     	; 0x1212 <spi_tranceiver+0x20>
		//give the slave some time to set its data
		asm("nop");	              
	}
#endif
	
	SPDR = data; // Load data into the buffer
    1202:	9f b9       	out	0x0f, r25	; 15
	while(!(SPSR & (1<<SPIF) )); //Wait until transmission complete
    1204:	77 9b       	sbis	0x0e, 7	; 14
    1206:	fe cf       	rjmp	.-4      	; 0x1204 <spi_tranceiver+0x12>
	data = SPDR; //get data
    1208:	3f b1       	in	r19, 0x0f	; 15
		//give the slave some time to set its data
		asm("nop");	              
	}
#endif
	
	SPDR = data; // Load data into the buffer
    120a:	2f b9       	out	0x0f, r18	; 15
	while(!(SPSR & (1<<SPIF) )); //Wait until transmission complete
    120c:	77 9b       	sbis	0x0e, 7	; 14
    120e:	fe cf       	rjmp	.-4      	; 0x120c <spi_tranceiver+0x1a>
	data = SPDR; //get data
    1210:	2f b1       	in	r18, 0x0f	; 15

inline uint16_t spi_tranceiver(uint16_t data)
{
	uint16_t r = 0x00;
	
	r = spi_tranceiver_8(data >> 8) << 8;
    1212:	93 2f       	mov	r25, r19
    1214:	80 e0       	ldi	r24, 0x00	; 0
    1216:	30 e0       	ldi	r19, 0x00	; 0
    1218:	28 2b       	or	r18, r24
    121a:	39 2b       	or	r19, r25
	r = r | spi_tranceiver_8(data & 0xFF);
    return(r);
    121c:	c9 01       	movw	r24, r18
    121e:	08 95       	ret

00001220 <mcp23008_WriteReg>:
	return i2c_Read8(addr,read_data);
#endif
}

inline void mcp23008_WriteReg(uint8_t dev_addr, uint8_t reg,uint8_t value)
{
    1220:	1f 93       	push	r17
    1222:	58 2f       	mov	r21, r24
    1224:	14 2f       	mov	r17, r20
	if(reg < 0 || reg > 0x0A)
    1226:	6b 30       	cpi	r22, 0x0B	; 11
    1228:	68 f4       	brcc	.+26     	; 0x1244 <mcp23008_WriteReg+0x24>
	uint8_t addr = CALC_ADDR(dev_addr);
#ifdef _SPI_MODE
	//this is a moot operation, cause write is 0. just here for completeness
	//addr |= SPI_WRITE; 
	
	PORTB &= ~(1<<PB1);
    122a:	c1 98       	cbi	0x18, 1	; 24
	spi_tranceiver(REG_ADD(addr,reg));
    122c:	56 70       	andi	r21, 0x06	; 6
    122e:	95 2f       	mov	r25, r21
    1230:	90 64       	ori	r25, 0x40	; 64
    1232:	80 e0       	ldi	r24, 0x00	; 0
    1234:	26 2f       	mov	r18, r22
    1236:	30 e0       	ldi	r19, 0x00	; 0
    1238:	82 2b       	or	r24, r18
    123a:	93 2b       	or	r25, r19
    123c:	da df       	rcall	.-76     	; 0x11f2 <spi_tranceiver>
	spi_tranceiver_8(value);
    123e:	81 2f       	mov	r24, r17
    1240:	ce df       	rcall	.-100    	; 0x11de <spi_tranceiver_8>
	PORTB |= (1<<PB1);
    1242:	c1 9a       	sbi	0x18, 1	; 24
	return;
#else
	i2c_Write16(addr,REG_ADD(reg,value));
	return;
#endif
    1244:	1f 91       	pop	r17
    1246:	08 95       	ret

00001248 <mcp23008_ReadReg>:
	cprintf_debug("init!\n\r");
	
}

inline int8_t mcp23008_ReadReg(uint8_t dev_addr, uint8_t reg,uint8_t* read_data)
{
    1248:	cf 93       	push	r28
    124a:	df 93       	push	r29
    124c:	78 2f       	mov	r23, r24
    124e:	ea 01       	movw	r28, r20
	if(reg > 0x0A || read_data == NULL)
    1250:	6b 30       	cpi	r22, 0x0B	; 11
    1252:	98 f4       	brcc	.+38     	; 0x127a <mcp23008_ReadReg+0x32>
    1254:	41 15       	cp	r20, r1
    1256:	51 05       	cpc	r21, r1
    1258:	81 f0       	breq	.+32     	; 0x127a <mcp23008_ReadReg+0x32>
	{
		return -103;
	}
	
	uint8_t addr = CALC_ADDR(dev_addr);
    125a:	76 70       	andi	r23, 0x06	; 6
#ifdef _SPI_MODE
	addr |= SPI_READ;
	PORTB &= ~(1<<PB1);
    125c:	c1 98       	cbi	0x18, 1	; 24
	spi_tranceiver(REG_ADD(addr,reg));
    125e:	97 2f       	mov	r25, r23
    1260:	91 64       	ori	r25, 0x41	; 65
    1262:	80 e0       	ldi	r24, 0x00	; 0
    1264:	26 2f       	mov	r18, r22
    1266:	30 e0       	ldi	r19, 0x00	; 0
    1268:	82 2b       	or	r24, r18
    126a:	93 2b       	or	r25, r19
    126c:	c2 df       	rcall	.-124    	; 0x11f2 <spi_tranceiver>
	*read_data = spi_tranceiver_8(0x00);
    126e:	80 e0       	ldi	r24, 0x00	; 0
    1270:	b6 df       	rcall	.-148    	; 0x11de <spi_tranceiver_8>
    1272:	88 83       	st	Y, r24
	PORTB |= (1<<PB1);
    1274:	c1 9a       	sbi	0x18, 1	; 24
    1276:	81 e0       	ldi	r24, 0x01	; 1
    1278:	01 c0       	rjmp	.+2      	; 0x127c <mcp23008_ReadReg+0x34>
	return 1;
    127a:	89 e9       	ldi	r24, 0x99	; 153
#else
	i2c_Write8(addr,reg);
	return i2c_Read8(addr,read_data);
#endif
}
    127c:	df 91       	pop	r29
    127e:	cf 91       	pop	r28
    1280:	08 95       	ret

00001282 <mcp23008_init>:
#define CALC_ADDR(x) (BASE_23008_ADDR | (x & _DEV_ADDR))

int8_t _mcp23008_init[0x0F] = {0};

void mcp23008_init(uint8_t dev_addr)
{
    1282:	1f 93       	push	r17
    1284:	cf 93       	push	r28
    1286:	df 93       	push	r29
    1288:	18 2f       	mov	r17, r24
	cprintf_debug("init mcp23008\n\r");
	cprintf_debug_char(dev_addr);
	cprintf_debug("\n\r");
	cprintf_debug_char(_mcp23008_init[dev_addr & _DEV_ADDR]);
	cprintf_debug("\n\r");
	if(_mcp23008_init[dev_addr & _DEV_ADDR] != 0)
    128a:	c8 2f       	mov	r28, r24
    128c:	d0 e0       	ldi	r29, 0x00	; 0
    128e:	c6 70       	andi	r28, 0x06	; 6
    1290:	d0 70       	andi	r29, 0x00	; 0
    1292:	ca 5a       	subi	r28, 0xAA	; 170
    1294:	de 4f       	sbci	r29, 0xFE	; 254
    1296:	88 81       	ld	r24, Y
    1298:	88 23       	and	r24, r24
    129a:	f1 f4       	brne	.+60     	; 0x12d8 <mcp23008_init+0x56>
		return;
	
	cprintf_debug("init dev\n\r");

#ifdef _SPI_MODE
	spi_init_as(1);
    129c:	81 e0       	ldi	r24, 0x01	; 1
    129e:	19 df       	rcall	.-462    	; 0x10d2 <spi_init_as>
	
	//set the CS pin, we will use PB1
	DDRB |= (1<<PB1);
    12a0:	b9 9a       	sbi	0x17, 1	; 23
	PORTB |= (1<<PB1);
    12a2:	c1 9a       	sbi	0x18, 1	; 24
	cprintf_debug("i2c done\n\r");
#endif

#ifdef _SPI_MODE
	//enable the addressing registry
	mcp23008_WriteReg(dev_addr,IOCON,0b00001000);
    12a4:	81 2f       	mov	r24, r17
    12a6:	65 e0       	ldi	r22, 0x05	; 5
    12a8:	48 e0       	ldi	r20, 0x08	; 8
    12aa:	ba df       	rcall	.-140    	; 0x1220 <mcp23008_WriteReg>
	mcp23008_WriteReg(dev_addr,IOCON,0x00);
#endif
	cprintf_debug("IOCON\n\r");
	
	//basically, all we do is set all the default value's. just to be sure the device is set as expected
	mcp23008_WriteReg(dev_addr,IODIR,0xFF);	
    12ac:	81 2f       	mov	r24, r17
    12ae:	60 e0       	ldi	r22, 0x00	; 0
    12b0:	4f ef       	ldi	r20, 0xFF	; 255
    12b2:	b6 df       	rcall	.-148    	; 0x1220 <mcp23008_WriteReg>
	cprintf_debug("IODIR\n\r");	
	mcp23008_WriteReg(dev_addr,GPINTEN,0x00);
    12b4:	81 2f       	mov	r24, r17
    12b6:	62 e0       	ldi	r22, 0x02	; 2
    12b8:	40 e0       	ldi	r20, 0x00	; 0
    12ba:	b2 df       	rcall	.-156    	; 0x1220 <mcp23008_WriteReg>
	cprintf_debug("GPINTEN\n\r");
	mcp23008_WriteReg(dev_addr,IPOL,0x00);
    12bc:	81 2f       	mov	r24, r17
    12be:	61 e0       	ldi	r22, 0x01	; 1
    12c0:	40 e0       	ldi	r20, 0x00	; 0
    12c2:	ae df       	rcall	.-164    	; 0x1220 <mcp23008_WriteReg>
	cprintf_debug("IPOL\n\r");
	mcp23008_WriteReg(dev_addr,GPPU,0x00);
    12c4:	81 2f       	mov	r24, r17
    12c6:	66 e0       	ldi	r22, 0x06	; 6
    12c8:	40 e0       	ldi	r20, 0x00	; 0
    12ca:	aa df       	rcall	.-172    	; 0x1220 <mcp23008_WriteReg>
	cprintf_debug("GGPU\n\r");
	mcp23008_WriteReg(dev_addr,GPIO,0x00);
    12cc:	81 2f       	mov	r24, r17
    12ce:	69 e0       	ldi	r22, 0x09	; 9
    12d0:	40 e0       	ldi	r20, 0x00	; 0
    12d2:	a6 df       	rcall	.-180    	; 0x1220 <mcp23008_WriteReg>
	cprintf_debug("GPIO\n\r");
	
	_mcp23008_init[dev_addr & _DEV_ADDR] = 1;
    12d4:	81 e0       	ldi	r24, 0x01	; 1
    12d6:	88 83       	st	Y, r24
	cprintf_debug("init!\n\r");
	
}
    12d8:	df 91       	pop	r29
    12da:	cf 91       	pop	r28
    12dc:	1f 91       	pop	r17
    12de:	08 95       	ret

000012e0 <strncmp>:
    12e0:	fb 01       	movw	r30, r22
    12e2:	dc 01       	movw	r26, r24
    12e4:	41 50       	subi	r20, 0x01	; 1
    12e6:	50 40       	sbci	r21, 0x00	; 0
    12e8:	30 f0       	brcs	.+12     	; 0x12f6 <strncmp+0x16>
    12ea:	8d 91       	ld	r24, X+
    12ec:	01 90       	ld	r0, Z+
    12ee:	80 19       	sub	r24, r0
    12f0:	19 f4       	brne	.+6      	; 0x12f8 <strncmp+0x18>
    12f2:	00 20       	and	r0, r0
    12f4:	b9 f7       	brne	.-18     	; 0x12e4 <strncmp+0x4>
    12f6:	88 1b       	sub	r24, r24
    12f8:	99 0b       	sbc	r25, r25
    12fa:	08 95       	ret

000012fc <strnlen>:
    12fc:	fc 01       	movw	r30, r24
    12fe:	61 50       	subi	r22, 0x01	; 1
    1300:	70 40       	sbci	r23, 0x00	; 0
    1302:	01 90       	ld	r0, Z+
    1304:	01 10       	cpse	r0, r1
    1306:	d8 f7       	brcc	.-10     	; 0x12fe <strnlen+0x2>
    1308:	80 95       	com	r24
    130a:	90 95       	com	r25
    130c:	8e 0f       	add	r24, r30
    130e:	9f 1f       	adc	r25, r31
    1310:	08 95       	ret

00001312 <_exit>:
    1312:	f8 94       	cli

00001314 <__stop_program>:
    1314:	ff cf       	rjmp	.-2      	; 0x1314 <__stop_program>
